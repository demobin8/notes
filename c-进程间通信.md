> ...

## 临界区

确保几个进程不能同时改变共享的值，称为互斥。所有的互斥实现都必须确保排它性原则。

## LINUX内核锁机制

### 自旋锁：

自旋锁用于保护短的代码段，基本是汇编实现。spin_trylock尝试获取锁时，不会阻塞。

spin_lock、spin_unlock。

### 信号量：

实质上，信号量只是受保护的特别变量，能表示为正负整数，初始值为1.

为操作信号量定义了两个标准操作：up和down。

down()后执行危险代码段，在执行down操作时，有一点特别重要。即从应用程序的角度来看，该操作应该视为一个原子操作。他不能被调度器调用中断，这意味着竟态条件时无法发生的。

如果没有内核的支持，这个过程是不可能的，因为用户空间无法保证down操作不被中断。

### RCU（read_copy_update）：

该机制记录了所有指向共享数据结构指针的使用者，在要修改时创建一个副本，在读写完旧的副本后，替换为新的修改后的副本的指针。

这种机制允许读写并发进行！

rcu_read_lock、rcu_read_unlock。

### 读写自旋锁：

上述机制为区分数据的读写访问，多个进程并发读数据，但只有一个进程能写数据，写时也不能读。

read_lock、read_unlock，write_lock、write_unlock。

### 互斥锁：

信号量可实现互斥的功能，但他的通用性导致的开销通常是不必要的。

经典互斥锁，mutex_init、mutex_lock,、mutex_unlock、mutex_trylock。

实时互斥锁，rt_mutex_init。。。

内核提供了如此多的锁原语，最大的挑战就是防止锁竞争和细粒度化锁，细粒度锁可以提高性能。

SYSTEM V进程间通信机制

信号量

消息队列

共享内存

其他IPC机制

信号

kill是命令行发送信号的方式，它根据PID向进程发送信号，sigaction、sigsuspend、sigprocmask。

kill -9 1000(pid) ，9号信号是SIGKILL信号； kill -2 1000， 2号信号是SIGINT信号

用户空间可以通过signal相关函数重写信号处理函数

管道和套接字
