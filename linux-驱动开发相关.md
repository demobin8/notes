> ...

系统中CPU不是唯一的智能设备，每一个物理外设都有其设备控制器。

键盘，鼠标和串行接口由多功能卡(SuperIO)控制，IDE磁盘由IDE控制器掌握，SCSI磁盘有SCSI控制器控制。

每一个于硬件控制器都有其自己的控制和状态寄存器(CSR)。

这些CSR在不同的设备中是不一的。一个Adaptec 2940 SCSI控制器的CSR与NCR810 SCSI控制器差别很大。CSR用来启动和停止一个设备，用来初始化一个设备和检测故障。

用来管理系统中硬件控制器的代码位于Linux核心中，而不是在每个应用程序中。用来管理硬件控制器的软件通常叫做设备驱动程序。

Linux核心的设备驱动程序基本上是一些共享库(Shared Library),在库中含有一些特权的，常住内存的，一些用来处理底层硬件的例程。

属性： 核心态、核心接口、核心机制和服务、可装卸、可重构、动态的。

为了知道这个设备命令是否完成，设备驱动程序有两种选择：(不断地)检测这个设备或使用中断。

中断控制器，一般集成在CPU中。

 
库函数与系统调用的关系与区别

简单用一个例子来说明：比如你使用printf函数时：      

首先会在C库中调用printf函数，在这个函数中会解析你里面的参数，比如你可能用了printf("...%d\n",i)之类的，这个C库函数就会把你所带的格式化参数完全转换成一个字符串，这时，C库里的printf函就会调用write系统调用，相当于将系统调用号放在eax寄存器中，并将后面的参数放在后面的寄存器中，并发出一个0x80的中断,让CPU进入中断模式，这就是系统调用 。所以你在用户应用程序中既可以调用C库函数，也可以自己实现如printf之类的函数，完全抛弃C库，但最终只能使用系统调用才能与内核通信，因为用户应用程序无法访问不属于自己的内存空间，也无法直接访问硬件设备，必需借助系统调用让自己进入内核模式，然后就由内核来完成你想要的操作，最终从内核空间返回用户态，此时同样的道理，内核也会将返回的参数放在寄存器中，如果参数过多，就会把参数结构指针的地址放在寄存器中，然后用户程序取回这些值，继续运行自己的程序 C库与内核有一定的依赖关系，虽然编译内核不需要C库的支持   比如，一个新的C库中的一个函数中调用了一个新的系统调用，而内核中却还未实现这个系统调用，那么用这个C库中的这个函数向内核发出软中断时，内核就无法识别，就会报错。当然，LINUX关于系统调用就几百个，而且一直以来没有多大变化，所以这种情况并不多见。

c编译程序采用一个预定义的函数库，其中的大部分函数具有系统调用的名字。解决了在用户程序中从用户态到核心态的状态变化。因为用户是不能直接操作内核的，必须通过系统调用。   

不是每个库函数都会进入核心态，但每个系统调用肯定会进入核心态。
