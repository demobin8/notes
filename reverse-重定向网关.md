> 这个网关很有意思，简单来说呢，它会伪装成各大视频站的服务端（通过旁路监听客户端发起的请求，然后伪造服务端的报文，抢先一步达到客户端），与客户端通信，告诉客户端一个假的P2P客户端信息，然后让客户端与我们的P2P客户端去通信，下载视频，达到一个加速的效果（项目的目标是为用户加速）。
> 
> 通过这个原理，其实还可以做很多事，比如在视频信息请求阶段，我就给一份伪造的视频信息，然后通过单一P2P通信，让客户端播放我给它的小电影。。。事实上我当年写这个服务的时候开发测试就一直播放的是同一个视频。。。挺有意思的

```
#include <stdlib.h>
#include <time.h>
#include <zlib.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <arpa/inet.h>
#include <netdb.h>
#include "pcap.h"   
#include "md5.h"   

#pragma pack(push)
#pragma pack(1)
struct ether_header   
{   
	u_int8_t    ether_dhost[6];   
	u_int8_t    ether_shost[6];   
	u_int16_t   ether_type;   
};   

struct ip_header   
{   
#ifdef WORDS_BIGENDIAN   
	u_int8_t        ip_version : 4,    
					ip_header_length : 4;       
#else   
	u_int8_t        ip_header_length : 4, ip_version : 4;   
#endif   
	u_int8_t        ip_tos;   
	u_int16_t       ip_length;   
	u_int16_t       ip_id;   
	u_int16_t       ip_off;   
	u_int8_t        ip_ttl;   
	u_int8_t        ip_protocol;   
	u_int16_t       ip_checksum;   
	struct in_addr  ip_source_address;   
	struct in_addr  ip_destination_address;   
};    

struct udp_header   
{   
	u_int16_t udp_source_port;   
	u_int16_t udp_destination_port;   
	u_int16_t udp_length;   
	u_int16_t udp_checksum;   
};   

struct tcp_header   
{   
	u_int16_t   tcp_source_port;   
	u_int16_t   tcp_destination_port;   
	u_int32_t   tcp_acknowledgement;   
	u_int32_t   tcp_ack;   
#ifdef WORDS_BIGENDIAN   
	u_int8_t    tcp_offset : 4,   
				tcp_reserved : 4;   
#else   
	u_int8_t    tcp_reserved : 4,   
				tcp_offset : 4;   
#endif   
	u_int8_t    tcp_flags;   
	u_int16_t   tcp_windows;   
	u_int16_t   tcp_checksum;   
	u_int16_t   tcp_urgent_pointer;   
};   

struct psd_header
{
	struct in_addr  source_address;   
	struct in_addr  destination_address;   
	uint8_t         padding;   
	uint8_t         protocol;   
	uint16_t 		size;
};

struct packet
{
	struct ether_header eth_hdr;
	struct ip_header ip_hdr;
	struct tcp_header tcp_hdr;
	struct udp_header udp_hdr;
	int data_len;
	char data[2048];
};

struct sohu_id_req
{
	uint16_t size;
	uint32_t fingerprint;
	uint16_t cmd;
	uint32_t order;
	uint16_t padding;
	uint8_t hashstr[20];
};

struct sohu_id_rsp
{
	uint16_t size;
	uint32_t fingerprint;
	uint16_t cmd;
	uint32_t order;
	uint8_t  hashstr[20];
};

struct sohu_ip_req
{
	uint16_t size;
	uint32_t fingerprint;
	uint16_t cmd;
	uint32_t order;
	uint8_t  hashstr[20];
	uint32_t mappedip;
	uint16_t mappedport;
	uint32_t localip;
	uint16_t localport;
	uint16_t count;
	uint8_t  id[8];
};

struct sohu_ip_rsp
{
	uint16_t size;
	uint32_t fingerprint;
	uint16_t cmd;
	uint32_t order;
	uint8_t  hashstr[20];
	uint32_t peerip;
	uint16_t peerport;
	uint32_t localip;
	uint16_t localport;
	uint8_t  id[4];
};

struct pps_vid_req
{
	uint8_t  size;
	uint16_t fingerprint;
	uint16_t cmd;
	uint32_t tvid;
	uint8_t  vid[32 + 1];
};

struct sohu_vid_req
{
	uint32_t size;
	uint32_t cmd;
	uint8_t  padding;
	uint32_t vid;
};

typedef struct _IQYTrackerReq
{
	uint32_t csum;
	uint32_t number1;
	uint16_t cmd;//1011
	uint32_t pad1;
	uint16_t pad2;
	uint32_t datalen;//24000000
	uint32_t count;
	uint8_t  id[16];
	uint8_t  hash[16];
}IQYTrackerReq;

typedef struct _IQYPeerInfo{
	uint16_t delim;//2b1f
	uint8_t  operator;
	uint32_t lanip;//host order
	uint16_t port1;//host order
	uint32_t wanip;//host order
	uint16_t port2;
	uint32_t stunip;
}IQYPeerInfo;

typedef struct _IQYTrackerRsp
{
	uint32_t csum;
	uint32_t number1;
	uint16_t cmd;//1012
	uint32_t pad1;//0
	uint16_t pad2;//0
	uint32_t datalen;//ca030000
	uint8_t  hash[16];
	uint32_t count;
	IQYPeerInfo info;
}IQYTrackerRsp;

struct pps_tracker_req
{
	uint16_t pktlen;// 6400 0x64 100
	uint16_t cmd1; // 4474 0x7444
	uint8_t  cmd2; // 0x71
	uint32_t unid11; // dd59cf28
	uint32_t unid12; // 782f3509
	uint32_t un11; // 0b000000
	uint32_t pad11; // 00000000
	uint8_t  idlen; // ? 0x14
	uint8_t  unid2[20];//79faa0ce 3a1987d0 776ddc47 12fa25be c85cf49e
	uint32_t un2; // 00009c01 
	uint8_t  un21[8]; // 00000101 00000c28 
	uint8_t  un22; // 0x01 
	uint16_t padun2; 
	uint32_t locip; // net order
	uint16_t locport; // net order
	uint8_t  un3[16]; // 04000000 00004800 0000ffff 00000000
	uint16_t un4;
	uint8_t  pad[9];
	uint8_t  ppsstr[8]; //'PPStream'
	uint8_t  pad2[2];	
};

struct pps_node_info
{
	uint32_t fingerprint; //1483010b 主机序0x0b018314
	uint32_t ip; // net order
	uint16_t tcpport; // host order
	uint16_t udpport; // host order
	uint8_t  pad;
	uint8_t  refcnt;
	uint16_t pad1;
	uint8_t  operator;
	uint16_t citycode;
	uint8_t  pad2;
};

struct pps_tracker_rsp
{
	uint16_t pktlen;
	uint16_t cmd1; // 5575 0x7555
	uint8_t  cmd2; // 0x17
	uint32_t unid11; // req.unid11
	uint32_t unid12; // req.unid12
	uint32_t un11; // 270b0000
	uint32_t pad11; // 00000000
	uint8_t  idlen; // ? 0x14
	uint8_t  unid2[20]; //req.unid2
	uint8_t  un2[11]; //00001100 00001a1a 1a1a 0a
	uint8_t  nodecnt;
	struct pps_node_info node; // nodeinfo*nodecnt 
	uint8_t  unend[175];
#if 0
	uint8_t  un3[5]; //fe78ff46 14
	uint8_t  pad[20]; 
	uint32_t un41; // xxxxxx42
	uint32_t un42; // xxxxxx43
	uint32_t un43; // xxxxxx42
	uint32_t un44; // xxxxxx42 
	uint8_t  pad2[8];
	uint32_t un5;
	uint32_t un6;
	uint32_t un7;
	uint32_t un8;
	uint32_t un9;
	uint32_t un10;
	uint8_t  un11; //0x14
	uint8_t  un12[20];
	uint8_t  un13; //0x8b
	uint8_t  pad3[4];
	uint32_t un14; //08004001 0x01400008
	uint8_t  pad4[7];
	uint32_t un15;
	uint8_t  pad5[4];
	uint32_t un16; //8b000000 0x8b
	uint8_t  un17[7]; //
	uint8_t  pad6[5];
	uint8_t  un17[41]; //
#endif
};

typedef struct _PPTVTrackerReq
{
    uint32_t un1;//rand
    uint8_t  cmd;//\x31
    uint8_t  un20;//=req.un20
    uint16_t un21;//=req.un21
    uint16_t un3;//\x00\x01
    uint16_t delim;//\x0c\x01
    uint16_t pad;
    uint8_t  vid[16];
    uint8_t  id[16];
    uint16_t cnt;//\x32
    uint8_t  un4;//\xff
}PPTVTrackerReq;

typedef struct _PPTVPeerInfo
{
    uint32_t lanip;//\x58\x01\xa8\xc0
    uint16_t lanport;//\x3b\xc9
    uint16_t delim;//\x0c\x01
    uint32_t wanip;//\x58\x01\xa8\xc0
    uint16_t wanport;//\x3b\xc9
    uint32_t un1;
    uint32_t un2;
    uint16_t un3;
}PPTVPeerInfo;

typedef struct _PPTVTrackerRsp
{
    uint32_t un1;//rand
    uint8_t  cmd;//\x31
    uint8_t  un20;//=req.un20
    uint16_t un21;//=req.un21
    uint8_t  pad[3];
    uint8_t  vid[16];
    uint16_t cnt;
    PPTVPeerInfo peerinfo;
}PPTVTrackerRsp;

struct funshion_tracker_req
{
	uint32_t rand;
	uint32_t len;
	uint32_t fingerprint;
	uint16_t ordernum;
	uint16_t unknown;
	uint8_t  videohash[20];
	uint32_t clipsnum;
	uint8_t  peerid[20];
	uint32_t wanip;
	uint32_t localip;
	uint32_t unknown2;
	uint32_t unknown3;
	uint32_t version;
	uint32_t unknown4;
};

struct funshion_tracker_rsp
{
	uint32_t rand;
	uint32_t len;
	uint32_t fingerprint;
	uint16_t ordernum;
	uint16_t unknown;
	uint32_t unknown1;
	uint32_t clipsnum;
	uint32_t unknown2;
	uint32_t unknown3;
};

#pragma pack(pop)

struct fingerprint
{
	u_char fingerprint[1024];
	int fingerprint_offset;
	int fingerprint_len;
	int fingerprint_owner;
};

pcap_t              *pcap_handle;   
pcap_t              *pcap_handle_send;   

int redirectip[32];
int redirectipcnt;

#define SOHU_TRACKER_FINGERPRINT 1
#define SOHU_RESOURCE_FINGERPRINT 2
#define HTTP_HOST_BAIDU 3
#define PPS_TRACKER_FINGERPRINT 4
#define PPS_RESOURCE_FINGERPRINT 5
#define IQY_TRACKER_FINGERPRINT 6
#define PPTV_TRACKER_FINGERPRINT 7
struct fingerprint fingerprints[] = {
	{{0x2a, 0x3c, 0xf8, 0x5e}, 2, 4, SOHU_TRACKER_FINGERPRINT},
	{{0x47, 0x45, 0x54, 0x20, 0x2f, 0x76, 0x72, 0x73, 0x5f, 0x66, 0x6c, 0x61, 0x73, 0x68, 0x2e, 0x61, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x3f, 0x76, 0x69, 0x64, 0x3d}, 0, 26, SOHU_RESOURCE_FINGERPRINT},
	{{0x48, 0x6f, 0x73, 0x74, 0x3a, 0x20, 0x77, 0x77, 0x77, 0x2e, 0x62, 0x61, 0x69, 0x64, 0x75, 0x2e, 0x63, 0x6f, 0x6d, 0x0d, 0x0a}, 0, 21, HTTP_HOST_BAIDU},
	{{0x44, 0x74, 0x71}, 2, 3, PPS_TRACKER_FINGERPRINT},
	{{'G', 'E', 'T', ' ', '/', 'v', 'p', '/'}, 0, 8, PPS_RESOURCE_FINGERPRINT},
	{{0x00, 0x00, 0x10, 0x11, 0x00, 0x00}, 6, 6, IQY_TRACKER_FINGERPRINT},
	{{0x00, 0x01, 0x0c, 0x01, 0x00, 0x00}, 8, 6, PPTV_TRACKER_FINGERPRINT},
};

uint32_t crc32_table[256];  

int initcrc32(void)  
{  
	uint32_t c;  
	int i = 0;  
	int bit = 0;  

	for(i = 0; i < 256; i++)  
	{  
		c  = (uint32_t)i;  

		for(bit = 0; bit < 8; bit++)  
		{  
			if(c&1)  
			{  
				c = (c >> 1)^(0xEDB88320);  
			}  
			else  
			{  
				c =  c >> 1;  
			}  

		}  
		crc32_table[i] = c;  
	}  
}  

uint32_t mycrc32(uint32_t crc, unsigned char *string, uint32_t size)  
{  

	while(size--)  
		crc = (crc >> 8)^(crc32_table[(crc ^ *string++)&0xff]);  

	return crc;  
}  

uint32_t getrand(uint32_t max)
{
	srand((int)time(NULL));
	return  (int)(max * rand()/(RAND_MAX + 1.0));
}

int gethostinfo(uint8_t *host, uint32_t *ipbuf)
{
	struct addrinfo *res = NULL, *p = NULL, hint = {'\0'};  
	hint.ai_family = AF_INET;
	hint.ai_socktype = SOCK_STREAM;
	int ret = 0, i = 0;   
	uint8_t ipstr[16] = {'\0'};

	ret = getaddrinfo(host, NULL, &hint, &res);   
	if(ret < 0)   
	{   
		printf("Can't get address info! error code = %d\n", ret);   
		return ret;   
	}   

	for(i = 0, p = res; p != NULL; p = p->ai_next, i++)
	{   
		ipbuf[i] = ((struct sockaddr_in *)p->ai_addr)->sin_addr.s_addr;   
		inet_ntop(AF_INET, &(((struct sockaddr_in *)(p->ai_addr))->sin_addr), ipstr, sizeof(ipstr));
		printf("host %s addr[%d]: %s\n", host, i, ipstr);
	}   

	freeaddrinfo(res);
	return i;
}

uint16_t ip_checksum(uint8_t *ptr, int size)  
{  
	int cksum = 0;  
	int index = 0;  

	*(ptr + 10) = 0;  
	*(ptr + 11) = 0;  

	if(size % 2 != 0)  
		return 0;  

	while(index < size)  
	{          
		cksum += *(ptr + index + 1);  
		cksum += *(ptr + index) << 8;  

		index += 2;  
	}  

	while(cksum > 0xffff)  
	{  
		cksum = (cksum >> 16) + (cksum & 0xffff);  
	}  
	return ~cksum;  
}  

uint16_t udp_checksum(uint16_t *ipaddr, uint16_t *udp, uint16_t udpsize)
{
	uint16_t pad = 0;
	uint32_t csum = ipaddr[0];

	csum += ipaddr[1] + ipaddr[2] + ipaddr[3] + htons(17) + htons(udpsize);

	csum += udp[0] + udp[1] + udp[2];

	udpsize -= 8;
	udp += 4;

	while (udpsize >= 32) {
		csum += udp[0] + udp[1] + udp[2] + udp[3] + udp[4] + udp[5] + udp[6] +
			udp[7] + udp[8] + udp[9] + udp[10] + udp[11] + udp[12] + udp[13] +
			udp[14] + udp[15];
		udpsize -= 32;
		udp += 16;
	}

	while(udpsize >= 8) {
		csum += udp[0] + udp[1] + udp[2] + udp[3];
		udpsize -= 8;
		udp += 4;
	}

	while(udpsize >= 4) {
		csum += udp[0] + udp[1];
		udpsize -= 4;
		udp += 2;
	}

	while (udpsize > 1) {
		csum += udp[0];
		udp += 1;
		udpsize -= 2;
	}

	if (udpsize == 1) {
		*(uint8_t *)(&pad) = (*(uint8_t *)udp);
		csum += pad;
	}

	csum = (csum >> 16) + (csum & 0x0000FFFF);
	csum += (csum >> 16);

	uint16_t csum_u16 = (uint16_t)~csum;
	if (csum_u16 == 0)
		return 0xFFFF;
	else
		return csum_u16;
}

uint16_t tcp_checksum(uint16_t *ipaddr, uint16_t *tcp, uint16_t tcpsize)
{
	uint16_t pad = 0;
	uint32_t csum = ipaddr[0];

	csum += ipaddr[1] + ipaddr[2] + ipaddr[3] + htons(6) + htons(tcpsize);

	csum += tcp[0] + tcp[1] + tcp[2] + tcp[3] + tcp[4] + tcp[5] + tcp[6] +
		tcp[7] + tcp[9];

	tcpsize -= 20;
	tcp += 10;

	while (tcpsize >= 32) {
		csum += tcp[0] + tcp[1] + tcp[2] + tcp[3] + tcp[4] + tcp[5] + tcp[6] +
			tcp[7] + tcp[8] + tcp[9] + tcp[10] + tcp[11] + tcp[12] + tcp[13] +
			tcp[14] + tcp[15];
		tcpsize -= 32;
		tcp += 16;
	}

	while(tcpsize >= 8) {
		csum += tcp[0] + tcp[1] + tcp[2] + tcp[3];
		tcpsize -= 8;
		tcp += 4;
	}

	while(tcpsize >= 4) {
		csum += tcp[0] + tcp[1];
		tcpsize -= 4;
		tcp += 2;
	}

	while (tcpsize > 1) {
		csum += tcp[0];
		tcp += 1;
		tcpsize -= 2;
	}

	if (tcpsize == 1) {
		*(uint8_t *)(&pad) = (*(uint8_t *)tcp);
		csum += pad;
	}

	csum = (csum >> 16) + (csum & 0x0000FFFF);
	csum += (csum >> 16);

	return (uint16_t)~csum;
}

unsigned cnt = 0;

unsigned char sohu_data[]=
{	0x1E,0x00,
	0x0A,0x0A,0x4D,0xC7,0x48,0xF0,0xB3,0xCE,0x02,0xE3,0xC9,0x32,0x0E,
	0x0A,0x0A,0x34,0x45,0x57,0x70,0xB7,0xEE,0x07,0x81,0xE3,0xEB,0x0E,0x0A,
	0x0A,0x34,0x47,0x4A,0x50,0x74,0x73,0x04,0xCF,0x6D,0xE3,0x0E,0x0A,0x0A,0x4D,0xC7,
	0x49,0x90,0x13,0xCF,0x04,0xAB,0x14,0xD9,0x0A,0x0A,0x0A,0x34,0x0A,0x45,0x60,0xA3,
	0x67,0x04,0x3D,0x86,0xB1,0x0B,0x0A,0x0A,0x34,0x47,0x43,0xE0,0x83,0x71,0x04,0x7D,
	0x1C,0x4B,0x0F,0x0A,0x0A,0x34,0x42,0x4A,0xF0,0x54,0x70,0x07,0x5B,0xAA,0x8D,0x09,
	0x0A,0x0A,0x34,0x07,0x41,0xE0,0x20,0x6F,0x07,0xB7,0x93,0x84,0x0B,0x0A,0x0A,0x34,
	0x46,0x4F,0x00,0x42,0xEB,0x07,0xEA,0x2B,0x7F,0x07,0x0A,0x0A,0x35,0x16,0x56,0x10,
	0xFE,0x77,0x07,0xA2,0x86,0x3F,0x0F,0x0A,0x0A,0x4D,0xC7,0x46,0x40,0x29,0xCE,0x07,
	0x9D,0xCA,0x45,0x0F,0x0A,0x0A,0x34,0x07,0x44,0xE0,0xCE,0x6C,0x07,0x3F,0x72,0x8D,
	0x0D,0x0A,0x0A,0x34,0x43,0x59,0x10,0xF9,0x79,0x07,0x71,0x31,0xED,0x0D,0x0A,0x0A,
	0x4D,0xC7,0x48,0x40,0x4D,0xCF,0x03,0xCE,0x7E,0x41,0x0F,0x0A,0x0A,0x34,0x46,0x4B,
	0x10,0x6A,0xEB,0x03,0x10,0xA5,0xF4,0x05,0x0A,0x0A,0x34,0x46,0x5C,0x30,0x7F,0xEB,
	0x03,0xA7,0xCA,0x0A,0x0E,0x0A,0x0A,0x34,0x06,0x44,0x10,0x26,0x6B,0x03,0x8A,0x88,
	0xC5,0x0E,0x0A,0x0A,0x34,0x48,0x4C,0x70,0xBF,0xFA,0x03,0xAF,0x05,0xD0,0x05,0x0A,
	0x0A,0x35,0x01,0x44,0x80,0xF4,0xE9,0x03,0x5A,0x73,0x65,0x0C,0x0A,0x0A,0x4D,0xC6,
	0x43,0x40,0xA4,0xDA,0x07,0x16,0x35,0x43,0x0F,0x0A,0x0A,0x35,0x01,0x4E,0x80,0x4A,
	0xE9,0x07,0x69,0x66,0x4F,0x0A,0x0A,0x0A,0x34,0x46,0x51,0x30,0x4C,0xEB,0x03,0x4C,0xFD,0x89,0x09,
	0x0A,0x0A,0x4D,0xC6,0x41,0xF0,0xAD,0xD8,0x03,0x70,0x20,0x2C,0x0F,0x0A,0x0A,0x34,
	0x44,0x5C,0x10,0xAD,0xD4,0x04,0xA4,0x7D,0xB2,0x02,0x0A,0x0A,0x34,0x09,0x4E,0x50,
	0x7F,0x18,0x07,0x72,0xA8,0x2E,0x02,0x0A,0x0A,0x34,0x42,0x43,0xC0,0x77,0x6F,0x07,
	0x17,0x44,0x3A,0x0F,0x0A,0x0A,0x34,0x06,0x4E,0xF0,0xBB,0x6A,0x03,0xB6,0x0B,0xA3,
	0x0C,0x0A,0x0A,0x34,0x07,0x53,0xF0,0xFF,0x6E,0x04,0xAC,0x66,0x42,0x0F,0x0A,0x0A,
	0x53,0xC8,0x46,0x60,0xDC,0xE1,0x03,0xAB,0x99,0x43,0x0F,0x0A,0x0A,0x34,0x07,0x4F,
	0x50,0xE8,0x6F,0x03,0xF0,0xDF,0xF3,0x0B
};

unsigned char funshion_data[] = {
	0x04, 0x01, 0xe5, 0x3e, 0x00, 0xc0, 0x12, 0x00, 0xed, 0xb8, 0x60, 0xa4, 0x4c, 0x2a, 0x10, 0x18, 
	0x0a, 0x9e, 0xc9, 0xb0, 0xc0, 0xa8, 0x01, 0x58, 0xc0, 0xa8, 0x01, 0x58, 0x00, 0x00, 0x00, 0x00, 
	0xc9, 0x3b, 0x00, 0x00, 0x09
};

unsigned char rawdata[] = {
	0xa2, 0xf0, 0x41, 0x4c, 0xce, 0xb9, 0x1f, 0x0d, 0x1d, 0xf6, 0xa4, 0x92, 0x0c, 0x94, 0x67, 0x91, 
	0xdb, 0x2d, 0xdc, 0x85, 0xbc, 0x78, 0xae, 0xb1, 0xbe, 0x96, 0x84, 0xea, 0xda, 0x03, 0x94, 0xcc, 
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x4d, 0xd0, 0x5b, 0x48, 0x93, 0x71, 
	0x18, 0x06, 0xf0, 0xe7, 0xbf, 0x13, 0x7e, 0xdf, 0x96, 0xae, 0x4f, 0x6b, 0xfa, 0x85, 0x90, 0x90, 
	0xb1, 0x25, 0xa4, 0x10, 0x2b, 0x0f, 0x89, 0xca, 0x14, 0x5c, 0x79, 0x31, 0x91, 0xd2, 0x94, 0x40, 
	0xb2, 0x2c, 0x1c, 0x16, 0x96, 0x69, 0x6a, 0x66, 0x04, 0x13, 0xc1, 0x79, 0x80, 0xbc, 0x30, 0x4c, 
	0x77, 0xe1, 0x20, 0x1b, 0xd1, 0x51, 0xca, 0xec, 0x34, 0x26, 0x66, 0xda, 0x95, 0x1a, 0x5e, 0x78, 
	0x9c, 0x82, 0xa0, 0xc2, 0x2a, 0xcb, 0x84, 0xcc, 0xa0, 0xff, 0xcb, 0x20, 0xe4, 0xe5, 0xb9, 0xfb, 
	0xf1, 0xbc, 0x2f, 0x2f, 0x10, 0x2f, 0x03, 0x1a, 0x0c, 0x39, 0x26, 0x13, 0xcd, 0x29, 0x7e, 0x88, 
	0xae, 0xd1, 0xa8, 0x14, 0x73, 0xe2, 0x24, 0x25, 0x6a, 0x94, 0x06, 0x50, 0x02, 0x0f, 0x3c, 0x84, 
	0x4e, 0x9a, 0xc7, 0x5a, 0xdd, 0xa9, 0x41, 0x94, 0xea, 0x6e, 0x1d, 0xa3, 0xec, 0x40, 0x6f, 0xee, 
	0x12, 0xca, 0xd7, 0x69, 0xb7, 0x6b, 0xaa, 0x82, 0xa8, 0xaa, 0x66, 0x5b, 0x4b, 0xd9, 0x81, 0x7a, 
	0x62, 0x08, 0x5d, 0x7d, 0x3f, 0x6e, 0x69, 0xac, 0x0b, 0xa2, 0xba, 0x46, 0xcb, 0x38, 0xe5, 0x3f, 
	0x52, 0x20, 0x6f, 0x16, 0x07, 0x24, 0xec, 0x3b, 0x53, 0xec, 0xce, 0x49, 0xb0, 0xc9, 0xa2, 0xab, 
	0x21, 0xbb, 0x56, 0xd3, 0x79, 0xcb, 0xdb, 0xc7, 0x4a, 0x05, 0x1d, 0x20, 0xe8, 0xc2, 0x98, 0xa0, 
	0xc0, 0x50, 0x08, 0xa1, 0xcf, 0x6d, 0x91, 0x17, 0x9f, 0xe6, 0xe9, 0x23, 0x45, 0x97, 0xfd, 0xf8, 
	0x74, 0xc1, 0xc6, 0x6e, 0x8e, 0xca, 0xc5, 0x11, 0x40, 0x1c, 0x31, 0x30, 0xa6, 0xc0, 0x64, 0x80, 
	0xd0, 0x4c, 0x59, 0x82, 0xe3, 0x61, 0x37, 0xa1, 0x13, 0xbf, 0x2e, 0xd8, 0xcc, 0x8d, 0x1c, 0x29, 
	0xb6, 0x92, 0x80, 0xad, 0x24, 0x81, 0xd0, 0x9f, 0x29, 0x42, 0x3f, 0x73, 0x2b, 0xbf, 0x98, 0x1b, 
	0x08, 0x0d, 0xd6, 0x3b, 0x03, 0xa1, 0x69, 0x94, 0x35, 0x17, 0xb0, 0xe6, 0x4a, 0xe3, 0xeb, 0xd8, 
	0xd0, 0x4b, 0xe4, 0xf3, 0x75, 0xc7, 0x8a, 0x15, 0xfd, 0x3a, 0x8e, 0xee, 0x19, 0x06, 0x2a, 0xe4, 
	0x18, 0x0f, 0x6f, 0xba, 0xbc, 0xba, 0x01, 0xac, 0x6e, 0xa8, 0x78, 0x93, 0xd2, 0x94, 0x8d, 0x4d, 
	0x09, 0x31, 0x9f, 0xfc, 0xea, 0xe1, 0x1f, 0x1c, 0x75, 0xea, 0x3e, 0x24, 0x1b, 0xf5, 0x1a, 0x6f, 
	0x1f, 0x6c, 0x72, 0x1c, 0x0d, 0x13, 0x98, 0x92, 0xed, 0x29, 0x42, 0xa1, 0x84, 0xe8, 0xf9, 0xca, 
	0xf8, 0x4b, 0x56, 0x8e, 0xba, 0x85, 0xd4, 0x6b, 0x3e, 0x4d, 0x3f, 0x6f, 0xb2, 0x07, 0x11, 0xc0, 
	0x91, 0xfd, 0x28, 0xa1, 0x92, 0x17, 0xf0, 0x97, 0x9e, 0x26, 0xb4, 0xeb, 0x76, 0x7f, 0x97, 0xd5, 
	0xc9, 0x9b, 0xec, 0x3e, 0x8b, 0x1c, 0xe7, 0xb3, 0xf0, 0xc3, 0x95, 0xac, 0x63, 0x16, 0xb1, 0x12, 
	0xee, 0x17, 0xbe, 0x7d, 0x3c, 0x3c, 0xc5, 0x51, 0x4f, 0xc0, 0x9d, 0x6c, 0x1c, 0xb8, 0xce, 0x9b, 
	0xd4, 0x73, 0xa1, 0xc0, 0x5c, 0x28, 0x21, 0x45, 0xb9, 0x07, 0x4d, 0x12, 0x62, 0x4d, 0xc6, 0x89, 
	0x4c, 0x87, 0x2d, 0x52, 0xec, 0x62, 0x7f, 0x93, 0x93, 0x9a, 0x8a, 0xbc, 0x7d, 0xfa, 0x12, 0xf5, 
	0x12, 0xa0, 0x5e, 0x0a, 0x23, 0xb4, 0x38, 0x42, 0x68, 0x35, 0x73, 0xe1, 0x79, 0xdd, 0x34, 0x6f, 
	0xea, 0xca, 0x7a, 0x52, 0xa1, 0x8b, 0x1e, 0xe4, 0x4d, 0xaa, 0x8c, 0x15, 0x39, 0x2e, 0x63, 0x25, 
	0x82, 0x23, 0xe5, 0x7a, 0x19, 0x3a, 0x25, 0xfc, 0x0e, 0xc0, 0x9f, 0x13, 0x42, 0x7f, 0x7a, 0x77, 
	0xe7, 0x55, 0x96, 0xf5, 0x06, 0x47, 0x42, 0xf0, 0xf0, 0xbd, 0x8c, 0xa9, 0x70, 0xf0, 0x10, 0x9e, 
	0x49, 0x38, 0xec, 0x59, 0xd8, 0xfc, 0xde, 0x42, 0x2f, 0x10, 0x72, 0xab, 0x6b, 0x5f, 0x7f, 0xa3, 
	0x58, 0x6f, 0xd2, 0x84, 0x33, 0xa5, 0x0a, 0x2d, 0x40, 0x9b, 0x04, 0x87, 0x93, 0xdf, 0x64, 0xe0, 
	0xa8, 0x63, 0x71, 0x98, 0xf9, 0xc4, 0x66, 0xde, 0x54, 0x53, 0xd0, 0x0b, 0x14, 0xf4, 0xea, 0xa9, 
	0xc9, 0xb5, 0x42, 0xc8, 0x70, 0x6e, 0xd6, 0x31, 0x7f, 0xaa, 0x5d, 0x16, 0xdb, 0xbb, 0x13, 0xeb, 
	0xaf, 0x7c, 0x9d, 0xe0, 0xe8, 0xbc, 0x29, 0x3d, 0xc5, 0x6d, 0x4a, 0xd7, 0x32, 0x51, 0xc5, 0xf6, 
	0x9f, 0x85, 0x57, 0x82, 0x71, 0x06, 0xce, 0xad, 0x7a, 0x7a, 0xc1, 0xf4, 0xa3, 0xea, 0xe6, 0x23, 
	0x11, 0xe2, 0x47, 0xa6, 0x5d, 0x5f, 0x06, 0xd6, 0x97, 0xc3, 0x19, 0xfb, 0x07, 0x17, 0x69, 0xce, 
	0x5d, 0xe4, 0x02, 0x00, 0x00, 
};

void tcp_send_rsp_pkt(struct packet *pkt, uint8_t *data, int data_len)
{
	struct packet pkt_tmp = {'\0'};
	uint8_t pkt_buf[2048] = {'\0'};
	uint8_t tmp[2048] = {'\0'};
	int offset = 0; int i = 0; int offset_tcphdr = 0;
	struct psd_header psd_hdr = {'\0'};

	memcpy(&pkt_tmp, pkt, sizeof(struct packet));
	memcpy(pkt_tmp.eth_hdr.ether_dhost, pkt->eth_hdr.ether_shost, sizeof(pkt_tmp.eth_hdr.ether_dhost));
	memcpy(pkt_tmp.eth_hdr.ether_shost, pkt->eth_hdr.ether_dhost, sizeof(pkt_tmp.eth_hdr.ether_shost));
	memcpy(pkt_buf + offset, (uint8_t *)&pkt_tmp.eth_hdr, sizeof(pkt_tmp.eth_hdr));

	pkt_tmp.ip_hdr.ip_destination_address = pkt->ip_hdr.ip_source_address;
	pkt_tmp.ip_hdr.ip_source_address = pkt->ip_hdr.ip_destination_address;
	pkt_tmp.ip_hdr.ip_id = pkt->ip_hdr.ip_id + 0x0010;
	pkt_tmp.ip_hdr.ip_off = 0x40;
	pkt_tmp.ip_hdr.ip_length = ntohs(data_len + sizeof(struct ip_header) + sizeof(struct tcp_header));
	pkt_tmp.ip_hdr.ip_checksum = ntohs(ip_checksum((uint8_t *)&pkt_tmp.ip_hdr, sizeof(struct ip_header)));
	offset += sizeof(pkt_tmp.eth_hdr);
	memcpy(pkt_buf + offset, (uint8_t *)&pkt_tmp.ip_hdr, sizeof(pkt_tmp.ip_hdr));

	pkt_tmp.tcp_hdr.tcp_destination_port = pkt->tcp_hdr.tcp_source_port;
	pkt_tmp.tcp_hdr.tcp_source_port = pkt->tcp_hdr.tcp_destination_port;
	//pkt_tmp.tcp_hdr.tcp_acknowledgement = htonl(pkt->tcp_hdr.tcp_ack);
	pkt_tmp.tcp_hdr.tcp_acknowledgement = pkt->tcp_hdr.tcp_ack;
	//pkt_tmp.tcp_hdr.tcp_ack = htonl(pkt->tcp_hdr.tcp_acknowledgement + pkt->data_len);
	pkt_tmp.tcp_hdr.tcp_ack = htonl(htonl(pkt->tcp_hdr.tcp_acknowledgement) + pkt->data_len);
	pkt_tmp.tcp_hdr.tcp_checksum = 0;
	//pkt_tmp.tcp_hdr.tcp_flags += 1;
	offset += sizeof(pkt_tmp.ip_hdr);
	offset_tcphdr = offset;

	memcpy(pkt_buf + offset, (uint8_t *)&pkt_tmp.tcp_hdr, sizeof(pkt_tmp.tcp_hdr));
	offset += sizeof(pkt_tmp.tcp_hdr);

	memcpy(pkt_buf + offset, data, data_len);
	offset += data_len;

	psd_hdr.source_address = pkt_tmp.ip_hdr.ip_source_address;
	psd_hdr.destination_address = pkt_tmp.ip_hdr.ip_destination_address;
	psd_hdr.protocol = pkt_tmp.ip_hdr.ip_protocol;
	psd_hdr.size = sizeof(struct tcp_header) + data_len;
	pkt_tmp.tcp_hdr.tcp_checksum = tcp_checksum((uint16_t *)&psd_hdr, (uint16_t *)(pkt_buf + sizeof(struct ip_header) + sizeof(struct ether_header)), psd_hdr.size);
	memcpy(pkt_buf + offset_tcphdr, (uint8_t *)&pkt_tmp.tcp_hdr, sizeof(pkt_tmp.tcp_hdr));
	pcap_sendpacket(pcap_handle_send, pkt_buf, offset);

	for(i = 0; i < offset; i++)
	{
		sprintf(tmp, "%s%02x", tmp, pkt_buf[i]);
	}
	printf("%s\n", tmp);
}

void udp_send_rsp_pkt(struct packet *pkt, uint8_t *data, int data_len)
{
	struct packet pkt_tmp = {'\0'};
	uint8_t pkt_buf[2048] = {'\0'};
	uint8_t tmp[2048] = {'\0'};
	int offset = 0; int i = 0; int offset_udphdr = 0;
	struct psd_header psd_hdr = {'\0'};

	memcpy(&pkt_tmp, pkt, sizeof(struct packet));
	memcpy(pkt_tmp.eth_hdr.ether_dhost, pkt->eth_hdr.ether_shost, sizeof(pkt_tmp.eth_hdr.ether_dhost));
	memcpy(pkt_tmp.eth_hdr.ether_shost, pkt->eth_hdr.ether_dhost, sizeof(pkt_tmp.eth_hdr.ether_shost));
	memcpy(pkt_buf + offset, (uint8_t *)&pkt_tmp.eth_hdr, sizeof(pkt_tmp.eth_hdr));

	pkt_tmp.ip_hdr.ip_destination_address = pkt->ip_hdr.ip_source_address;
	pkt_tmp.ip_hdr.ip_source_address = pkt->ip_hdr.ip_destination_address;
	//pkt_tmp.ip_hdr.ip_id = pkt->ip_hdr.ip_id + 0x0010;
	pkt_tmp.ip_hdr.ip_id = 0;
	pkt_tmp.ip_hdr.ip_off = 0x40;
	pkt_tmp.ip_hdr.ip_length = ntohs(data_len + sizeof(struct ip_header) + sizeof(struct udp_header));
	pkt_tmp.ip_hdr.ip_checksum = ntohs(ip_checksum((uint8_t *)&pkt_tmp.ip_hdr, sizeof(struct ip_header)));
	offset += sizeof(pkt_tmp.eth_hdr);
	memcpy(pkt_buf + offset, (uint8_t *)&pkt_tmp.ip_hdr, sizeof(pkt_tmp.ip_hdr));

	pkt_tmp.udp_hdr.udp_destination_port = pkt->udp_hdr.udp_source_port;
	pkt_tmp.udp_hdr.udp_source_port = pkt->udp_hdr.udp_destination_port;
	pkt_tmp.udp_hdr.udp_checksum = 0;
	pkt_tmp.udp_hdr.udp_length = ntohs(data_len + sizeof(struct udp_header));

	offset += sizeof(pkt_tmp.ip_hdr);
	offset_udphdr = offset;

	memcpy(pkt_buf + offset, (uint8_t *)&pkt_tmp.udp_hdr, sizeof(pkt_tmp.udp_hdr));
	offset += sizeof(pkt_tmp.udp_hdr);

	memcpy(pkt_buf + offset, data, data_len);
	offset += data_len;

	psd_hdr.source_address = pkt_tmp.ip_hdr.ip_source_address;
	psd_hdr.destination_address = pkt_tmp.ip_hdr.ip_destination_address;
	psd_hdr.protocol = pkt_tmp.ip_hdr.ip_protocol;
	psd_hdr.size = sizeof(struct udp_header) + data_len;
	pkt_tmp.udp_hdr.udp_checksum = udp_checksum((uint16_t *)&psd_hdr, (uint16_t *)(pkt_buf + sizeof(struct ip_header) + sizeof(struct ether_header)), psd_hdr.size);
	memcpy(pkt_buf + offset_udphdr, (uint8_t *)&pkt_tmp.udp_hdr, sizeof(pkt_tmp.udp_hdr));
	pcap_sendpacket(pcap_handle_send, pkt_buf, offset);

	for(i = 0; i < offset; i++)
	{
		sprintf(tmp, "%s%02x", tmp, pkt_buf[i]);
	}
	printf("%s\n", tmp);
}

void sohu_tracker_handle(struct packet *pkt)
{
	uint16_t cmd = *((uint16_t *)(pkt->data + 2 + 4));
	struct packet pkt_tmp = {'\0'};
	uint8_t pkt_buf[2048] = {'\0'};
	uint8_t tmp[2048] = {'\0'};
	int offset = 0; int i = 0; int offset_tcphdr = 0;

	switch(cmd)
	{
		case 0x8026:
			{
				struct sohu_id_req *req = (struct sohu_id_req*)pkt->data;
				struct sohu_id_rsp rsp = {'\0'};
				rsp.size = sizeof(rsp) + sizeof(sohu_data);
				rsp.fingerprint = req->fingerprint;
				rsp.cmd = 0x8006;
				rsp.order = req->order;
				memcpy(rsp.hashstr, req->hashstr, sizeof(rsp.hashstr));
				memcpy(pkt_buf, (uint8_t *)&rsp, sizeof(rsp));
				offset += sizeof(rsp);
				memcpy(pkt_buf + offset, sohu_data, sizeof(sohu_data));
				offset += sizeof(sohu_data);
				tcp_send_rsp_pkt(pkt, pkt_buf, offset);
				break;
			}
		case 0x8007:
			{
				struct sohu_ip_req *ipreq = (struct sohu_ip_req*)pkt->data;
				struct sohu_ip_rsp iprsp = {'\0'};
				iprsp.size = sizeof(iprsp);
				iprsp.fingerprint = ipreq->fingerprint;
				iprsp.cmd = 0x8007;
				iprsp.order = ipreq->order;
				memcpy(iprsp.hashstr, ipreq->hashstr, sizeof(iprsp.hashstr));
				iprsp.peerip = inet_addr("192.168.1.88");
				iprsp.peerport = ntohs(51515);
				iprsp.localip = inet_addr("192.168.1.88");
				iprsp.localport = ntohs(51515);
				iprsp.id[0] = 0xE3;
				iprsp.id[1] = 0xC9;
				iprsp.id[2] = 0x32;
				iprsp.id[3] = 0x0E;
				memcpy(pkt_buf, (uint8_t *)&iprsp, sizeof(iprsp));
				offset += sizeof(iprsp);
				tcp_send_rsp_pkt(pkt, pkt_buf, offset);
				break;
			}
		default:
			break;
	}
}

void pps_resource_handle(struct packet *pkt)
{
	if(strstr(pkt->data, "Host: cache.video.qiyi.com") == 0)
		return;
	char tvidstrbuf[32] = {'\0'};
	char vidstrbuf[32 + 1] = {'\0'};
	char *ptvidend = NULL;
	ptvidend = strchr(pkt->data + 8, '/');
	if(ptvidend == NULL) return ;
	memcpy(tvidstrbuf, pkt->data + 8, ptvidend - (pkt->data + 8));
	uint32_t tvid = atoi(tvidstrbuf);
	char *pvidend = NULL;
	pvidend = strchr(ptvidend + 1, '/');
	if(pvidend == NULL || pvidend - ptvidend - 1 != 32) return ;
	memcpy(vidstrbuf, ptvidend + 1, 32);

	struct pps_vid_req req = {'\0'};
	req.size = sizeof(req);
	req.fingerprint = 0x9001;
	req.cmd = 0x1234;
	req.tvid = tvid;
	strcpy(req.vid, vidstrbuf);
	int sd = socket(AF_INET, SOCK_DGRAM, 0);
	struct sockaddr_in addr = {'\0'};
	addr.sin_family = AF_INET;
	addr.sin_port = htons(51517);
	addr.sin_addr.s_addr = inet_addr("192.168.1.88");
	sendto(sd, (uint8_t*)&req, req.size, 0, (struct sockaddr*)&addr, sizeof(struct sockaddr_in));
	printf("request tvid: %d, vid: %s\n", req.tvid, req.vid);
}

void sohu_resource_handle(struct packet *pkt)
{
	char vidstrbuf[32] = {'\0'};
	int len = pkt->data_len - 26;
	int i = 26;
	while(len > 0)
	{
		if(pkt->data[i] < 0x30 || pkt->data[i] > 0x39)
		{
			break;
		}
		i += 1;
	}
	memcpy(vidstrbuf, &(pkt->data[26]), i - 26);
	uint32_t vid = atoi(vidstrbuf);

	struct sohu_vid_req req = {'\0'};
	req.size = sizeof(req);
	req.cmd = 0x9001;
	req.vid = vid;
	int sd = socket(AF_INET, SOCK_DGRAM, 0);
	struct sockaddr_in addr = {'\0'};
	addr.sin_family = AF_INET;
	addr.sin_port = htons(51515);
	addr.sin_addr.s_addr = inet_addr("192.168.1.88");
	sendto(sd, (uint8_t*)&req, req.size, 0, (struct sockaddr*)&addr, sizeof(struct sockaddr_in));
	printf("request vid: %u\n", vid);
}

uint8_t key2[128];

void initKey2()
{
	key2[ 0   ] = 0xa6;
	key2[ 1   ] = 0xe2;
	key2[ 2   ] = 0x47;
	key2[ 3   ] = 0xdc;
	key2[ 4   ] = 0x0d;
	key2[ 5   ] = 0x70;
	key2[ 6   ] = 0x71;
	key2[ 7   ] = 0x21;
	key2[ 8   ] = 0x6d;
	key2[ 9   ] = 0x21;
	key2[ 10  ] = 0x28;
	key2[ 11  ] = 0xdd;
	key2[ 12  ] = 0xd1;
	key2[ 13  ] = 0x6d;
	key2[ 14  ] = 0x20;
	key2[ 15  ] = 0xa4;
	key2[ 16  ] = 0xac;
	key2[ 17  ] = 0x88;
	key2[ 18  ] = 0x0a;
	key2[ 19  ] = 0x75;
	key2[ 20  ] = 0xd5;
	key2[ 21  ] = 0x7f;
	key2[ 22  ] = 0x12;
	key2[ 23  ] = 0xd4;
	key2[ 24  ] = 0x8a;
	key2[ 25  ] = 0x26;
	key2[ 26  ] = 0x0a;
	key2[ 27  ] = 0x65;
	key2[ 28  ] = 0xb4;
	key2[ 29  ] = 0x52;
	key2[ 30  ] = 0xc4;
	key2[ 31  ] = 0xb9;
	key2[ 32  ] = 0x6c;
	key2[ 33  ] = 0x49;
	key2[ 34  ] = 0xbf;
	key2[ 35  ] = 0x68;
	key2[ 36  ] = 0xbf;
	key2[ 37  ] = 0x77;
	key2[ 38  ] = 0x06;
	key2[ 39  ] = 0x60;
	key2[ 40  ] = 0xae;
	key2[ 41  ] = 0x63;
	key2[ 42  ] = 0x56;
	key2[ 43  ] = 0x7c;
	key2[ 44  ] = 0x79;
	key2[ 45  ] = 0xe1;
	key2[ 46  ] = 0x7f;
	key2[ 47  ] = 0x59;
	key2[ 48  ] = 0x1e;
	key2[ 49  ] = 0x88;
	key2[ 50  ] = 0x0c;
	key2[ 51  ] = 0x65;
	key2[ 52  ] = 0x1c;
	key2[ 53  ] = 0x66;
	key2[ 54  ] = 0x26;
	key2[ 55  ] = 0x38;
	key2[ 56  ] = 0x7c;
	key2[ 57  ] = 0xf3;
	key2[ 58  ] = 0xb6;
	key2[ 59  ] = 0x28;
	key2[ 60  ] = 0x12;
	key2[ 61  ] = 0x44;
	key2[ 62  ] = 0xca;
	key2[ 63  ] = 0x17;
	key2[ 64  ] = 0x01;
	key2[ 65  ] = 0x81;
	key2[ 66  ] = 0x3a;
	key2[ 67  ] = 0x90;
	key2[ 68  ] = 0x7d;
	key2[ 69  ] = 0x99;
	key2[ 70  ] = 0x8b;
	key2[ 71  ] = 0x13;
	key2[ 72  ] = 0xd5;
	key2[ 73  ] = 0x34;
	key2[ 74  ] = 0x13;
	key2[ 75  ] = 0xac;
	key2[ 76  ] = 0xb0;
	key2[ 77  ] = 0xea;
	key2[ 78  ] = 0x5e;
	key2[ 79  ] = 0xca;
	key2[ 80  ] = 0x96;
	key2[ 81  ] = 0xb2;
	key2[ 82  ] = 0xd1;
	key2[ 83  ] = 0x4f;
	key2[ 84  ] = 0xb3;
	key2[ 85  ] = 0x9d;
	key2[ 86  ] = 0x8d;
	key2[ 87  ] = 0xe4;
	key2[ 88  ] = 0xd8;
	key2[ 89  ] = 0xc4;
	key2[ 90  ] = 0x97;
	key2[ 91  ] = 0x8f;
	key2[ 92  ] = 0xc3;
	key2[ 93  ] = 0x7e;
	key2[ 94  ] = 0x35;
	key2[ 95  ] = 0x87;
	key2[ 96  ] = 0xa0;
	key2[ 97  ] = 0xd7;
	key2[ 98  ] = 0x9b;
	key2[ 99  ] = 0x47;
	key2[ 100 ] = 0xd0;
	key2[ 101 ] = 0x3e;
	key2[ 102 ] = 0xc6;
	key2[ 103 ] = 0xe1;
	key2[ 104 ] = 0xe8;
	key2[ 105 ] = 0x7e;
	key2[ 106 ] = 0xa9;
	key2[ 107 ] = 0x95;
	key2[ 108 ] = 0xfd;
	key2[ 109 ] = 0xf0;
	key2[ 110 ] = 0x87;
	key2[ 111 ] = 0xa2;
	key2[ 112 ] = 0x1f;
	key2[ 113 ] = 0xee;
	key2[ 114 ] = 0xa0;
	key2[ 115 ] = 0x5c;
	key2[ 116 ] = 0x23;
	key2[ 117 ] = 0x8a;
	key2[ 118 ] = 0x0f;
	key2[ 119 ] = 0x7f;
	key2[ 120 ] = 0xa6;
	key2[ 121 ] = 0x80;
	key2[ 122 ] = 0xf3;
	key2[ 123 ] = 0xc3;
	key2[ 124 ] = 0x4e;
	key2[ 125 ] = 0x6a;
	key2[ 126 ] = 0xcd;
	key2[ 127 ] = 0xb0;
}

#define CHUNK 10240
int decodeGz(uint8_t *data, int datalen, uint8_t **output, int *outputlen)
{ 
	int ret; 
	unsigned have; 
	z_stream strm; 
	unsigned char out[CHUNK]; 

	strm.zalloc = Z_NULL; 
	strm.zfree = Z_NULL; 
	strm.opaque = Z_NULL; 
	strm.avail_in = 0; 
	strm.next_in = Z_NULL; 

	if(data[0] == 0x1f && data[1] == 0x8b)
	{
		ret = inflateInit2(&strm, 47); 
	}
	else 
	{
		ret = inflateInit(&strm); 
	}

	if(ret != Z_OK) 
	{
		printf("inflateinit failed...\n");
		return -1;
	}

	strm.avail_in = datalen; 
	strm.next_in = data; 

	do   
	{ 
		strm.avail_out = CHUNK; 
		strm.next_out = out; 
		ret = inflate(&strm, Z_NO_FLUSH); 
		if(ret == Z_STREAM_ERROR) 
		{
			printf("inflate error...\n");
			return -1;
		}
		switch(ret)   
		{ 
			case Z_NEED_DICT: 
				ret = Z_DATA_ERROR; 
			case Z_DATA_ERROR: 
			case Z_MEM_ERROR: 
				inflateEnd(&strm); 
				return ret; 
		} 
		have = CHUNK - strm.avail_out; 
		*outputlen += have; 
		*output = realloc(*output, *outputlen); 
		memcpy(*output + *outputlen - have, out, have); 
	}while(strm.avail_out == 0); 

	(void)inflateEnd(&strm); 
	return ret == Z_STREAM_END ? Z_OK : Z_DATA_ERROR; 
}

int encodeGz(uint8_t *data, int datalen, uint8_t *output, int outputlen)
{
	z_stream strm;
	strm.zalloc = Z_NULL;
	strm.zfree  = Z_NULL;
	strm.opaque = Z_NULL;

	strm.avail_in = datalen;
	strm.avail_out = outputlen;
	strm.next_in = data;
	strm.next_out = output;

	int err = -1;
	err = deflateInit2(&strm, Z_DEFAULT_COMPRESSION, Z_DEFLATED, MAX_WBITS + 16, MAX_MEM_LEVEL, Z_DEFAULT_STRATEGY);

	if (err == Z_OK)
	{
		err = deflate(&strm, Z_FINISH);
		if (err == Z_STREAM_END)
		{
			(void)deflateEnd(&strm);
			return outputlen - strm.avail_out;
		}
		else
		{
			(void)deflateEnd(&strm);
			printf("compression failed\n");
			return -1;
		}
	}
	else
	{
		(void)deflateEnd(&strm);
		printf("compression initialization failed\n");
		return -1;
	}
}

int funshion_decode1(uint8_t *data, int len)
{
	int i = 0; uint16_t key = -1;
	for(i = 0; i < len; i += 2)
	{
		if(i < 4) continue;
		if(i >= 32) return -1;
		if(i == 4) key = *((uint16_t *)(data + i));
		if(i + 2 > len)
		{
			//last one
			*((uint8_t *)(data + i)) ^= (uint8_t)(key & 0xff);
		}
		else
		{
			*((uint16_t *)(data + i)) ^=  key;
		}
	}
}

int funshion_numOfDecode2(uint8_t *data)
{
	uint8_t index = 8 * (data[2]/16 & 0xf);	
	data[3] ^= key2[index];
	return data[3];
}

int funshion_encode2_2(uint8_t *data, int len)
{
	int i = 4; 
	uint32_t unknown = *((uint16_t *)data)<<16|*((uint16_t *)data);
	//int lenbak = 0xfffffffc & data[3];
	int lenbak = 32;
	int index = 8 * (*(uint8_t *)(data + 2)/16 & 0xf);
	while(i < lenbak)
	{
		while(index < 124 && i < lenbak)
		{
			*((uint32_t *)(data + i)) ^= unknown^(*(uint32_t *)(&key2[index]));
			i += 4;
			index += 4;
		}
		index = 0;
	}
}

int funshion_decode2_2(uint8_t *data, int len)
{
	int i = 4; 
	uint32_t unknown = *((uint16_t *)data)<<16|*((uint16_t *)data);
	//int lenbak = 0xfffffffc & data[3];
	int lenbak = 32;
	int index = 8 * (*(uint8_t *)(data + 2)/16 & 0xf);
	while(i < lenbak)
	{
		while(index < 124 && i < lenbak)
		{
			*((uint32_t *)(data + i)) ^= unknown^(*(uint32_t *)(&key2[index]));
			i += 4;
			index += 4;
		}
		index = 0;
	}
}

void funshion_tracker_handle_tcp(struct packet *pkt)
{
	struct funshion_tracker_req *req = (struct funshion_tracker_req *)pkt->data;
	struct funshion_tracker_rsp rsp = {'\0'};
	uint8_t peers[37 * 14] = {'\0'};
	memcpy(peers, funshion_data, sizeof(peers));
	uint8_t buf[CHUNK] = {'\0'};
	int outputlen = encodeGz(funshion_data, sizeof(funshion_data), buf, sizeof(buf));
	//rsp.rand = getrand(0xffffff)<<8 | 0x20;
	rsp.rand = 0x20710ff8;
	rsp.len = htonl(32 + outputlen);
	rsp.fingerprint = 0x02007100;
	rsp.ordernum = req->ordernum;
	rsp.unknown = htons(0xe30d);
	rsp.unknown1 = 0x2c013c00;
	rsp.clipsnum = 0x24000000;
	rsp.unknown2 = 0x22000000;
	rsp.unknown3 = 0x14800204;
	uint8_t *sendbuf = NULL;
	sendbuf = (uint8_t *)calloc((sizeof(rsp) + outputlen), sizeof(uint8_t));
	memcpy(sendbuf, (uint8_t *)&rsp, sizeof(rsp));
	memcpy(sendbuf + sizeof(rsp), buf, outputlen);
	funshion_numOfDecode2(sendbuf);
	funshion_decode2_2(sendbuf, 32);
	//tcp_send_rsp_pkt(pkt, sendbuf, sizeof(rsp) + outputlen);
	tcp_send_rsp_pkt(pkt, (uint8_t *)&rsp, sizeof(rsp));
	free(sendbuf);
	sendbuf = NULL;
}

void funshion_tracker_handle_udp(struct packet *pkt)
{
	struct funshion_tracker_req *req = (struct funshion_tracker_req *)pkt->data;
	struct funshion_tracker_rsp rsp = {'\0'};
	uint8_t peers[37 * 14] = {'\0'};
	memcpy(peers, funshion_data, sizeof(funshion_data));
	uint8_t buf[CHUNK] = {'\0'};
	int outputlen = encodeGz(funshion_data, sizeof(funshion_data), buf, sizeof(buf));
	//rsp.rand = getrand(0xffffff)<<8 | 0x20;
	rsp.rand = 0x20710ff8;
	rsp.len = htonl(32 + outputlen);
	rsp.fingerprint = 0x02007100;
	rsp.ordernum = req->ordernum;
	rsp.unknown = htons(0xe30d);
	rsp.unknown1 = 0x2c013c00;
	rsp.clipsnum = 0x24000000;
	rsp.unknown2 = 0x22000000;
	rsp.unknown3 = 0x01800204;
	uint8_t *sendbuf = NULL;
	sendbuf = (uint8_t *)calloc((sizeof(rsp) + outputlen), sizeof(uint8_t));
	memcpy(sendbuf, (uint8_t *)&rsp, sizeof(rsp));
	memcpy(sendbuf + sizeof(rsp), buf, outputlen);
	funshion_numOfDecode2(sendbuf);
	funshion_decode2_2(sendbuf, 32);
	udp_send_rsp_pkt(pkt, sendbuf, sizeof(rsp) + outputlen);
	free(sendbuf);
	sendbuf = NULL;
}

uint8_t pps_unend[] = 
{
	0xfe, 0x78, 0xff, 0x46, 0x14, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x24, 0xdd, 0x5f, 0x42, 0xa0, 
	0x96, 0x7d, 0x43, 0xdb, 0x52, 0xd3, 0x42, 0xe7, 
	0xe1, 0x8c, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x85, 0x00, 0x00, 0x00, 0x60, 
	0x33, 0x00, 0x00, 0x5a, 0x01, 0x00, 0x00, 0x96, 
	0x1b, 0x00, 0x00, 0x70, 0x16, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x14, 0x08, 0x4a, 0x47, 0xe0, 
	0x67, 0x26, 0xc8, 0xf9, 0x90, 0xa2, 0xc3, 0xa3, 
	0x8f, 0xdd, 0x6d, 0xc9, 0x8f, 0x54, 0x0c, 0xa8, 
	0x8b, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x40, 
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x6a, 0x86, 0x09, 0x54, 0x00, 0x00, 0x00, 0x00, 
	0x8b, 0x00, 0x00, 0x00, 0x89, 0x22, 0x22, 0x55, 
	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0x82, 0x06, 0x00, 0x03, 0x00, 0x02, 0x10, 
	0x92, 0x00, 0xd6, 0xd0, 0xb9, 0xfa, 0x00, 0xb5, 
	0xe7, 0xd0, 0xc5, 0x00, 0xbb, 0xaa, 0xb6, 0xab, 
	0x00, 0xb8, 0xa3, 0xbd, 0xa8, 0x00, 0xcf, 0xc3, 
	0xc3, 0xc5, 0x00, 0x3d, 0x83, 0x4b, 0x4d, 0xa5, 
	0x2b 
};

uint8_t iqiyi_info[950] = {
    0x58, 0x01, 0xa8, 0xc0, 0x3b, 0xc9, 0x59, 0x01, 0xa8, 0xc0, 0x3b, 0xc9, 0x42, 0x4b, 0x54, 0x77, 
    0x2b, 0x1f, 0x06, 0x82, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0xa4, 0xee, 0xec, 0x72, 0x98, 0xab, 0x42, 
    0x0e, 0x6c, 0xca, 0x2b, 0x1f, 0x05, 0x68, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0x94, 0xc4, 0x47, 0x7b, 
    0x57, 0x16, 0xc4, 0x0e, 0x6c, 0xca, 0x2b, 0x1f, 0x06, 0x65, 0x02, 0xa8, 0xc0, 0x04, 0x1c, 0x38, 
    0xac, 0xe5, 0x65, 0x0e, 0xa1, 0x43, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 0x06, 0x65, 0x01, 0xa8, 0xc0, 
    0x04, 0x1c, 0x6e, 0xb4, 0xbf, 0xde, 0x04, 0x1c, 0x42, 0x0e, 0x6c, 0xca, 0x2b, 0x1f, 0x03, 0x65, 
    0x01, 0xa8, 0xc0, 0x04, 0x1c, 0x48, 0x6d, 0x8e, 0xb7, 0x7f, 0x5e, 0x43, 0x4b, 0x54, 0x77, 0x2b, 
    0x1f, 0x03, 0x39, 0x0b, 0x14, 0xac, 0x04, 0x1c, 0x3a, 0xcb, 0xa2, 0xd3, 0x55, 0xa8, 0x42, 0x0e, 
    0x6c, 0xca, 0x2b, 0x1f, 0x06, 0x02, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0xc8, 0xfa, 0x9c, 0x1b, 0x04, 
    0x1c, 0x43, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 0x05, 0x69, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0x50, 0xac, 
    0xe4, 0x79, 0x02, 0x56, 0x0b, 0x63, 0x6b, 0x71, 0x2b, 0x1f, 0x03, 0x04, 0x01, 0xa8, 0xc0, 0x04, 
    0x1c, 0xbf, 0xf8, 0x6e, 0xab, 0x04, 0x1c, 0x42, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 0x05, 0x06, 0x01, 
    0xa8, 0xc0, 0x04, 0x1c, 0x7d, 0xd7, 0x42, 0x70, 0x04, 0x1c, 0x43, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 
    0x05, 0x68, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0x47, 0x51, 0x3e, 0x24, 0xc3, 0x42, 0x43, 0x4b, 0x54, 
    0x77, 0x2b, 0x1f, 0x06, 0x67, 0x01, 0xa8, 0xc0, 0x03, 0x1c, 0xaa, 0x9c, 0x6c, 0x0e, 0x03, 0x1c, 
    0x42, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 0x06, 0x69, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0x93, 0x43, 0x11, 
    0xda, 0x24, 0x49, 0x0b, 0x63, 0x6b, 0x71, 0x2b, 0x1f, 0x06, 0x64, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 
    0x30, 0x1a, 0x5f, 0xab, 0x8b, 0x04, 0x42, 0x0e, 0x6c, 0xca, 0x2b, 0x1f, 0x03, 0x68, 0x01, 0xa8, 
    0xc0, 0x04, 0x1c, 0x86, 0xd7, 0x47, 0x31, 0x02, 0x1e, 0x0b, 0x63, 0x6b, 0x71, 0x2b, 0x1f, 0x03, 
    0x6f, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0x46, 0x8d, 0x34, 0x3a, 0xce, 0xfc, 0x43, 0x4b, 0x54, 0x77, 
    0x2b, 0x1f, 0x03, 0x6a, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0xbf, 0x15, 0x40, 0xda, 0x04, 0x1c, 0x42, 
    0x4b, 0x54, 0x77, 0x2b, 0x1f, 0x06, 0x65, 0x02, 0xa8, 0xc0, 0x04, 0x1c, 0xf4, 0x6b, 0xf0, 0x7a, 
    0x16, 0xf3, 0x42, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 0x05, 0x17, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0xdf, 
    0x80, 0xcc, 0x8b, 0x04, 0x1c, 0x43, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 0x05, 0x64, 0x02, 0xa8, 0xc0, 
    0x04, 0x1c, 0xc6, 0xa3, 0x47, 0xde, 0x9e, 0xd7, 0x0b, 0x63, 0x6b, 0x71, 0x2b, 0x1f, 0x05, 0x87, 
    0x00, 0xa8, 0xc0, 0x04, 0x1c, 0x19, 0x91, 0x80, 0x77, 0x04, 0x1c, 0x43, 0x4b, 0x54, 0x77, 0x2b, 
    0x1f, 0x03, 0x03, 0x01, 0xa8, 0xc0, 0x05, 0x1c, 0x49, 0xf2, 0xa1, 0xdc, 0x05, 0x1c, 0x42, 0x4b, 
    0x54, 0x77, 0x2b, 0x1f, 0x05, 0x0a, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0xba, 0x6a, 0x2b, 0x78, 0x04, 
    0x1c, 0x43, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 0x05, 0x69, 0x00, 0xa8, 0xc0, 0x05, 0x1c, 0x0a, 0x20, 
    0x2e, 0x6a, 0xd1, 0x6b, 0x0b, 0x63, 0x6b, 0x71, 0x2b, 0x1f, 0x05, 0x03, 0x01, 0xa8, 0xc0, 0x04, 
    0x1c, 0x71, 0xd1, 0x68, 0xb4, 0x04, 0x1c, 0x42, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 0x01, 0x64, 0x01, 
    0xa8, 0xc0, 0x04, 0x1c, 0x2e, 0x0e, 0x85, 0xdb, 0x04, 0x1c, 0x43, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 
    0x06, 0x2d, 0x41, 0xfe, 0xa9, 0x04, 0x1c, 0x88, 0xb9, 0xbd, 0xdc, 0x04, 0x1c, 0x0b, 0x63, 0x6b, 
    0x71, 0x2b, 0x1f, 0x01, 0x70, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0x07, 0x5c, 0x01, 0x74, 0x70, 0xa0, 
    0x42, 0x0e, 0x6c, 0xca, 0x2b, 0x1f, 0x05, 0x3b, 0x67, 0xfe, 0xa9, 0x04, 0x1c, 0x5b, 0x5e, 0x92, 
    0xdf, 0x04, 0x1c, 0x43, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 0x01, 0x03, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 
    0xef, 0x16, 0xd1, 0x74, 0x04, 0x1c, 0x42, 0x0e, 0x6c, 0xca, 0x2b, 0x1f, 0x05, 0x74, 0x01, 0xa8, 
    0xc0, 0x04, 0x1c, 0xa9, 0xf2, 0xa6, 0x7c, 0xb2, 0x51, 0x50, 0x23, 0x5a, 0x70, 0x2b, 0x1f, 0x06, 
    0x06, 0xa9, 0x2d, 0x0a, 0x04, 0x1c, 0x07, 0xd1, 0x6b, 0xca, 0x0e, 0x76, 0x0b, 0x63, 0x6b, 0x71, 
    0x2b, 0x1f, 0x05, 0x65, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0x57, 0xcc, 0x39, 0x3b, 0x51, 0xb3, 0x42, 
    0x0e, 0x6c, 0xca, 0x2b, 0x1f, 0x03, 0x69, 0x01, 0xa8, 0xc0, 0x03, 0x1c, 0x9f, 0xc0, 0x3f, 0x24, 
    0x54, 0x40, 0x0b, 0x63, 0x6b, 0x71, 0x2b, 0x1f, 0x06, 0x6a, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0xf2, 
    0x19, 0x1d, 0xb7, 0x04, 0x1c, 0x43, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 0x06, 0xae, 0x5f, 0xfe, 0xa9, 
    0x04, 0x1c, 0xdc, 0xb0, 0xf7, 0x7a, 0x04, 0x1c, 0x42, 0x0e, 0x6c, 0xca, 0x2b, 0x1f, 0x01, 0x64, 
    0x01, 0xa8, 0xc0, 0x04, 0x1c, 0xce, 0x5d, 0xfd, 0x76, 0x04, 0x1c, 0x0b, 0x63, 0x6b, 0x71, 0x2b, 
    0x1f, 0x06, 0x06, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0xc4, 0xa9, 0x49, 0x71, 0x5b, 0x1d, 0x42, 0x4b, 
    0x54, 0x77, 0x2b, 0x1f, 0x07, 0x0e, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0xe8, 0x0d, 0xde, 0x0e, 0xb4, 
    0x16, 0x42, 0x0e, 0x6c, 0xca, 0x2b, 0x1f, 0x06, 0x67, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0x55, 0x01, 
    0x59, 0x31, 0xe1, 0x13, 0x0b, 0x63, 0x6b, 0x71, 0x2b, 0x1f, 0x06, 0x67, 0xa8, 0xa8, 0xc0, 0x04, 
    0x1c, 0x48, 0x8b, 0x96, 0x1b, 0x04, 0x1c, 0x0b, 0x63, 0x6b, 0x71, 0x2b, 0x1f, 0x05, 0x6a, 0x00, 
    0xa8, 0xc0, 0x04, 0x1c, 0xd9, 0x80, 0xf2, 0x7a, 0xd4, 0x6a, 0x43, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 
    0x05, 0x65, 0x04, 0xa8, 0xc0, 0x04, 0x1c, 0x26, 0x45, 0x56, 0xb6, 0x75, 0xe2, 0x0b, 0x63, 0x6b, 
    0x71, 0x2b, 0x1f, 0x05, 0x02, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0x6d, 0x68, 0x20, 0x6a, 0x04, 0x1c, 
    0x42, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 0x01, 0x81, 0x00, 0xa8, 0xc0, 0x04, 0x1c, 0xc0, 0xd3, 0xd0, 
    0x73, 0x04, 0x1c, 0x0b, 0x63, 0x6b, 0x71, 0x2b, 0x1f, 0x04, 0x66, 0x00, 0xa8, 0xc0, 0x04, 0x1c, 
    0x2c, 0xd0, 0xe1, 0x73, 0x93, 0x38, 0x43, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 0x05, 0x58, 0x01, 0xa8, 
    0xc0, 0x04, 0x1c, 0xe1, 0x34, 0xbb, 0x6e, 0x04, 0x1c, 0x43, 0x4b, 0x54, 0x77, 0x2b, 0x1f, 0x01, 
    0x39, 0x48, 0x11, 0xac, 0x04, 0x1c, 0x81, 0x8a, 0x65, 0xca, 0x05, 0x1c, 0x43, 0x4b, 0x54, 0x77, 
    0x2b, 0x1f, 0x05, 0x68, 0x01, 0xa8, 0xc0, 0x04, 0x1c, 0x70, 0x81, 0x50, 0x31, 0x22, 0x2a, 0x43, 
    0x4b, 0x54, 0x77, 0x2b, 0x1f, 0x05, 
};

void iqiyi_tracker_handle_udp(struct packet *pkt)
{
	IQYTrackerReq *req = (IQYTrackerReq *)pkt->data;
	IQYTrackerRsp rsp = {'\0'};
	rsp.number1 = req->number1;
	rsp.cmd = 0x1210;
	rsp.datalen = sizeof(rsp) - 20;
	memcpy(rsp.hash, req->hash, sizeof(rsp.hash));
	rsp.count = 1;
	rsp.info.delim = 0x1f2b;
	rsp.info.operator = 2;
	rsp.info.lanip = inet_network("192.168.1.88");
	rsp.info.port1 = 51515;
	rsp.info.wanip = inet_network("192.168.1.88");
	rsp.info.port2 = 51515;
	//rsp.info.stunip = inet_network("119.84.75.67");
	rsp.info.stunip = 0;
	uint8_t tmp[3] = {'\0'};
	memcpy(tmp, (uint8_t *)&(rsp.info), 3);
	memcpy((uint8_t *)&(rsp.info), (uint8_t *)&(rsp.info) + 3, sizeof(rsp.info) - 3);
	memcpy((uint8_t *)&(rsp.info) + sizeof(rsp.info) - 3, &tmp, 3);
	//memcpy((uint8_t *)&(rsp.info), iqiyi_info, sizeof(rsp.info));
	uint8_t data[1024] = {'\0'};
	memcpy(data, (uint8_t *)&rsp + 4, sizeof(rsp) - 4);
	memcpy(data + sizeof(rsp) - 4, "\xe3\xbe\xa5\x54", 4);
    	MD5_CTX ctx;
    	unsigned char hash[MD5_STR_LEN/2];
    	MD5_Init(&ctx);
    	MD5_Update(&ctx, (void *)data, sizeof(rsp));
    	MD5_Final(hash, &ctx);
	rsp.csum = (*((uint32_t *)&hash))^(*((uint32_t *)&hash[4]))^(*((uint32_t *)&hash[8]))^(*((uint32_t *)&hash[12]));
	udp_send_rsp_pkt(pkt, (uint8_t *)&rsp, sizeof(rsp));
}

void pps_tracker_handle_udp(struct packet *pkt)
{
	struct pps_tracker_req *req = (struct pps_tracker_req *)pkt->data;
	struct pps_tracker_rsp rsp = {'\0'};
	rsp.pktlen = sizeof(rsp);
	rsp.cmd1 = 0x7555;
	rsp.cmd2 = 0x17;
	rsp.unid11 = req->unid11;
	rsp.unid12 = req->unid12;
	rsp.un11 = 0x0000027b;
	rsp.idlen = 0x14;
	memcpy(rsp.unid2, req->unid2, sizeof(rsp.unid2));
	memcpy(rsp.un2, "\x00\x00\x11\x00\x00\x00\x1a\x1a\x1a\x1a\x0a", 11);
	rsp.nodecnt = 1;
	rsp.node.fingerprint = 0x0b018314;
	rsp.node.ip = inet_addr("192.168.1.88");
	rsp.node.tcpport = 51515;
	rsp.node.udpport = 51515;
	rsp.node.refcnt = 0xbb;
	rsp.node.operator = 0x2;
	rsp.node.citycode = htons(4240);
	memcpy(rsp.unend, pps_unend, sizeof(rsp.unend));
	udp_send_rsp_pkt(pkt, (uint8_t *)&rsp, sizeof(rsp));
}

unsigned int pptvchecksum(unsigned char *data, int len)
{
	int length = len - 4;
	data += 4;
	int cnt = length/8;
	int index = 0;
	unsigned int csum = 0x10312312;
	unsigned int h, l;
	while(cnt)
	{
		h = *(unsigned int*)(data + index);
		index += 4;
		l = *(unsigned int*)(data + index);
		csum ^= h ^ l ^ (csum >> 6) ^ (csum << 14);
		index += 4;
		cnt -= 1;
		length -= 8;
	}
	int i;
	for(i = 0; i < length; i++)
	{
		csum ^= *(data + index + i) ^ (csum << 7) ^ (csum >> 13);
	}
	return csum;
}

void pptv_tracker_handle_udp(struct packet *pkt)
{
unsigned char a[] = {
    0xc8, 0xbb, 0x87, 0x88, 0x31, 0x9d, 0x11, 0x00, 0x00, 0x00, 0x00, 0x51, 0x8d, 0xde, 0x0a, 0xe0, 
    0xa2, 0x3c, 0xab, 0xe1, 0x5b, 0xaa, 0x6e, 0x78, 0x06, 0x11, 0x96, 0x32, 0x00, 0x02, 0x0b, 0xa8, 
    0xc0, 0xb2, 0x13, 0x0c, 0x01, 0x2d, 0x2d, 0x3a, 0x01, 0xb2, 0x13, 0x65, 0x25, 0x5a, 0x70, 0x62, 
    0x1b, 0xff, 0x02, 0x00, 0x3e, 0x67, 0x01, 0xa8, 0xc0, 0xb2, 0x13, 0x0c, 0x01, 0x6d, 0x51, 0x74, 
    0xab, 0xb2, 0x13, 0x57, 0x25, 0x5a, 0x70, 0x67, 0x1b, 0xff, 0xfe, 0x00, 0x3e, 0x69, 0x01, 0xa8, 
    0xc0, 0xb1, 0x13, 0x0c, 0x01, 0x6a, 0xcc, 0x01, 0xdd, 0xa1, 0x5a, 0x57, 0x25, 0x5a, 0x70, 0x63, 
    0x1b, 0xff, 0xfe, 0x0d, 0x3e, 0x69, 0x00, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0x16, 0x9c, 0x96, 
    0x7b, 0x46, 0x1a, 0x3e, 0xf8, 0x92, 0xdb, 0x5b, 0x1b, 0xff, 0xfe, 0x1f, 0x35, 0x67, 0x01, 0xa8, 
    0xc0, 0xb1, 0x13, 0x0c, 0x01, 0xb3, 0x5e, 0xc6, 0x01, 0xfc, 0x20, 0x3d, 0xf8, 0x92, 0xdb, 0x64, 
    0x1b, 0xff, 0xc7, 0x7f, 0x35, 0x65, 0x01, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0x0e, 0xf0, 0x80, 
    0xb7, 0xb1, 0x13, 0xa3, 0xa6, 0xee, 0x73, 0x5a, 0x1b, 0xff, 0x0f, 0x00, 0x35, 0x6e, 0x01, 0xa8, 
    0xc0, 0xb3, 0x13, 0x0c, 0x01, 0x2f, 0x0c, 0xdb, 0x0e, 0xfa, 0xf8, 0x3d, 0xf8, 0x92, 0xdb, 0x5f, 
    0x1b, 0xff, 0xfe, 0x01, 0x35, 0x66, 0x00, 0xa8, 0xc0, 0xb2, 0x13, 0x0c, 0x01, 0xdd, 0xec, 0x48, 
    0x71, 0x6a, 0x68, 0x3e, 0xf8, 0x92, 0xdb, 0x5e, 0x1b, 0xff, 0x00, 0x00, 0x35, 0x64, 0x01, 0xa8, 
    0xc0, 0xb1, 0x13, 0x0c, 0x01, 0xe6, 0xfd, 0x4a, 0x6f, 0x39, 0x59, 0x8d, 0x40, 0xc2, 0xdd, 0x62, 
    0x1b, 0xff, 0x4d, 0x00, 0x35, 0x68, 0x01, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0xef, 0x02, 0x43, 
    0x31, 0xa8, 0x07, 0x3d, 0xf8, 0x92, 0xdb, 0x67, 0x1b, 0xff, 0xfe, 0x2e, 0x35, 0x66, 0x00, 0xa8, 
    0xc0, 0xb2, 0x13, 0x0c, 0x01, 0x64, 0xb2, 0x07, 0x7a, 0x6a, 0x68, 0x3e, 0xf8, 0x92, 0xdb, 0x59, 
    0x1b, 0xff, 0xfe, 0x00, 0x35, 0x6c, 0x00, 0xa8, 0xc0, 0xb2, 0x13, 0x0c, 0x01, 0x51, 0x35, 0x06, 
    0x6a, 0x1d, 0x75, 0xa3, 0xa6, 0xee, 0x73, 0x5c, 0x1b, 0xff, 0xfe, 0x00, 0x35, 0x67, 0x06, 0xa8, 
    0xc0, 0xb2, 0x13, 0x0c, 0x01, 0x0f, 0x7c, 0x65, 0x77, 0xb5, 0x3e, 0x0c, 0x64, 0xb8, 0x3d, 0x5b, 
    0x1b, 0xff, 0x0f, 0x0f, 0x35, 0x68, 0x01, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0xa8, 0xba, 0xbb, 
    0xdc, 0xa0, 0x49, 0xa3, 0xa6, 0xee, 0x73, 0x65, 0x1b, 0xff, 0x78, 0xe3, 0x35, 0x76, 0x1b, 0xa8, 
    0xc0, 0xb1, 0x13, 0x0c, 0x01, 0x9a, 0x5a, 0xe4, 0x74, 0x0e, 0x76, 0x0b, 0x64, 0xb8, 0x3d, 0x58, 
    0x1b, 0xff, 0x12, 0xff, 0x35, 0x64, 0x01, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0x66, 0x81, 0xfc, 
    0x70, 0x99, 0x09, 0x64, 0x25, 0x5a, 0x70, 0x5c, 0x1b, 0xff, 0x6d, 0x02, 0x34, 0xfc, 0x00, 0xa8, 
    0xc0, 0xb2, 0x13, 0x0c, 0x01, 0x02, 0xe0, 0x08, 0xda, 0xb2, 0x13, 0x57, 0x25, 0x5a, 0x70, 0x59, 
    0x1b, 0xff, 0x15, 0x01, 0x34, 0x65, 0x02, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0xd5, 0x31, 0xc5, 
    0x1b, 0xa8, 0x19, 0x64, 0x25, 0x5a, 0x70, 0x60, 0x1b, 0xff, 0x61, 0x07, 0x34, 0xf8, 0x46, 0xd6, 
    0x3a, 0xb1, 0x13, 0x0c, 0x01, 0xf8, 0x46, 0xd6, 0x3a, 0xb1, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x04, 0xfe, 0x00, 0x2b, 0xb2, 0x70, 0xa8, 0xc0, 0xb2, 0x13, 0x0c, 0x01, 0x91, 0xf0, 0xcf, 
    0x01, 0xb2, 0x13, 0x3d, 0xf8, 0x92, 0xdb, 0x67, 0x1b, 0xff, 0x18, 0x07, 0x2b, 0x66, 0x00, 0xa8, 
    0xc0, 0xb2, 0x13, 0x0c, 0x01, 0x2f, 0x4a, 0xb9, 0xb7, 0x6e, 0x44, 0x0c, 0x64, 0xb8, 0x3d, 0x67, 
    0x1b, 0xff, 0x94, 0x00, 0x2b, 0x64, 0x00, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0xb9, 0xd3, 0xa1, 
    0x3c, 0x71, 0x66, 0x0c, 0x64, 0xb8, 0x3d, 0x5e, 0x1b, 0xff, 0xfe, 0x00, 0x2b, 0xba, 0x1f, 0xa8, 
    0xc0, 0xb1, 0x13, 0x0c, 0x01, 0x41, 0x6e, 0x51, 0x31, 0xb1, 0x13, 0x3e, 0xf8, 0x92, 0xdb, 0x58, 
    0x1b, 0xff, 0xb2, 0x05, 0x2b, 0x71, 0x01, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0x46, 0x78, 0xf2, 
    0x71, 0xb7, 0x94, 0xa4, 0xa6, 0xee, 0x73, 0x62, 0x1b, 0xff, 0xae, 0x01, 0x2b, 0x6a, 0x01, 0xa8, 
    0xc0, 0xb2, 0x13, 0x0c, 0x01, 0x84, 0x38, 0x54, 0xde, 0xb2, 0x13, 0x3d, 0xf8, 0x92, 0xdb, 0x60, 
    0x1b, 0xff, 0x00, 0x00, 0x2b, 0x67, 0x01, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0xa4, 0xe9, 0x1b, 
    0x01, 0x62, 0x1f, 0x64, 0x25, 0x5a, 0x70, 0x64, 0x1b, 0xff, 0xfe, 0x00, 0x16, 0x66, 0x01, 0xa8, 
    0xc0, 0xb1, 0x13, 0x0c, 0x01, 0xe4, 0x80, 0x3b, 0x01, 0xb1, 0x13, 0x65, 0x25, 0x5a, 0x70, 0x58, 
    0x1b, 0xff, 0xfe, 0x00, 0x16, 0x9d, 0x01, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0x51, 0x3f, 0xb3, 
    0xa3, 0x8c, 0x5f, 0x65, 0x25, 0x5a, 0x70, 0x62, 0x1b, 0xff, 0x8e, 0x18, 0x16, 0x67, 0x01, 0xa8, 
    0xc0, 0xb1, 0x13, 0x0c, 0x01, 0xb1, 0x03, 0x8f, 0x7a, 0xb1, 0x13, 0x20, 0xb8, 0xa0, 0x7c, 0x5b, 
    0x1b, 0xff, 0x02, 0x00, 0x16, 0x6e, 0x01, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0x88, 0x0c, 0x5d, 
    0x7c, 0xb1, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x44, 0x00, 0x16, 0x3f, 0x64, 0x64, 
    0x64, 0xb1, 0x13, 0x0c, 0x01, 0xe9, 0xde, 0x63, 0xca, 0xb1, 0x13, 0x57, 0x25, 0x5a, 0x70, 0x5c, 
    0x1b, 0xff, 0xfe, 0x14, 0x16, 0x64, 0x01, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0x36, 0x9d, 0xbf, 
    0x77, 0xf9, 0xcb, 0x57, 0x25, 0x5a, 0x70, 0x65, 0x1b, 0xff, 0x18, 0x00, 0x16, 0x03, 0x01, 0xa8, 
    0xc0, 0xb2, 0x13, 0x0c, 0x01, 0xe5, 0x98, 0xe5, 0x2a, 0x7e, 0x12, 0x20, 0x40, 0xc2, 0xdd, 0x58, 
    0x1b, 0xff, 0xeb, 0x02, 0x0c, 0x1c, 0x9f, 0xf0, 0x6e, 0xb1, 0x13, 0x0c, 0x01, 0x1c, 0x9f, 0xf0, 
    0x6e, 0xb1, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0xfe, 0x00, 0x16, 0x64, 0x00, 0xa8, 
    0xc0, 0xb1, 0x13, 0x0c, 0x01, 0xc9, 0x27, 0x17, 0x3a, 0x08, 0x3c, 0x64, 0x25, 0x5a, 0x70, 0x59, 
    0x1b, 0xff, 0x0d, 0x00, 0x16, 0x68, 0x02, 0xa8, 0xc0, 0xb2, 0x13, 0x0c, 0x01, 0x4d, 0xc2, 0x10, 
    0x3a, 0xa1, 0x26, 0x64, 0x25, 0x5a, 0x70, 0x5e, 0x1b, 0xff, 0x4c, 0x00, 0x16, 0xb2, 0x70, 0xa8, 
    0xc0, 0xb2, 0x13, 0x0c, 0x01, 0x91, 0xf0, 0xcf, 0x01, 0xb2, 0x13, 0x3d, 0xf8, 0x92, 0xdb, 0x67, 
    0x1b, 0xff, 0x18, 0x07, 0x2b, 0x43, 0xe2, 0xbf, 0x77, 0xb1, 0x13, 0x0c, 0x01, 0x43, 0xe2, 0xbf, 
    0x77, 0xb1, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x40, 0x00, 0x0c, 0x2b, 0x4d, 0x24, 
    0x1b, 0xb1, 0x13, 0x0c, 0x01, 0x2b, 0x4d, 0x24, 0x1b, 0xb1, 0x13, 0x00, 0x00, 0x00, 0x00, 0x00, 
    0x00, 0x04, 0xfe, 0x8a, 0x0c, 0x6b, 0x00, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0xd6, 0xf5, 0x5e, 
    0x70, 0x55, 0x6d, 0x57, 0x25, 0x5a, 0x70, 0x58, 0x1b, 0xff, 0x77, 0x8e, 0x16, 0x66, 0x01, 0xa8, 
    0xc0, 0xb2, 0x13, 0x0c, 0x01, 0xc9, 0xd0, 0x02, 0x71, 0xc2, 0x7b, 0x57, 0x25, 0x5a, 0x70, 0x59, 
    0x1b, 0xff, 0x2f, 0x04, 0x0c, 0x6a, 0x01, 0xa8, 0xc0, 0xb2, 0x13, 0x0c, 0x01, 0x84, 0x38, 0x54, 
    0xde, 0xb2, 0x13, 0x3d, 0xf8, 0x92, 0xdb, 0x60, 0x1b, 0xff, 0x00, 0x00, 0x2b, 0x67, 0x01, 0xa8, 
    0xc0, 0xb1, 0x13, 0x0c, 0x01, 0xf7, 0x99, 0xd0, 0x3c, 0xd9, 0x0d, 0x65, 0x25, 0x5a, 0x70, 0x66, 
    0x1b, 0xff, 0x81, 0x0f, 0x16, 0x65, 0x01, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0xa9, 0x90, 0x99, 
    0x7b, 0xd9, 0x2b, 0x1f, 0xb8, 0xa0, 0x7c, 0x5d, 0x1b, 0xff, 0x7e, 0x06, 0x16, 0x65, 0x05, 0xa8, 
    0xc0, 0xb1, 0x13, 0x0c, 0x01, 0x2e, 0xa1, 0xc4, 0x1b, 0x9d, 0x37, 0x57, 0x25, 0x5a, 0x70, 0x58, 
    0x1b, 0xff, 0xfe, 0x0d, 0x16, 0x68, 0x01, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0x55, 0xb7, 0x2b, 
    0xaf, 0x3f, 0x0c, 0x65, 0x25, 0x5a, 0x70, 0x5f, 0x1b, 0xff, 0x48, 0x0e, 0x2a, 0x62, 0x01, 0xa8, 
    0xc0, 0xb1, 0x13, 0x0c, 0x01, 0x4d, 0x12, 0x06, 0x3c, 0xb1, 0x13, 0x20, 0x40, 0xc2, 0xdd, 0x5a, 
    0x1b, 0xff, 0xfd, 0x1a, 0x0c, 0x08, 0x5e, 0x01, 0x3c, 0xb1, 0x13, 0x0c, 0x01, 0x08, 0x5e, 0x01, 
    0x3c, 0xb1, 0x13, 0x20, 0x40, 0xc2, 0xdd, 0x58, 0x1b, 0x04, 0x67, 0x09, 0x16, 0x64, 0x01, 0xa8, 
    0xc0, 0xb1, 0x13, 0x0c, 0x01, 0x04, 0xa1, 0xb6, 0x77, 0xb1, 0x13, 0x65, 0x25, 0x5a, 0x70, 0x62, 
    0x1b, 0xff, 0x02, 0x01, 0x16, 0x01, 0xbf, 0xa8, 0xc0, 0xb1, 0x13, 0x0c, 0x01, 0xaf, 0xe6, 0x4e, 
    0x76, 0x59, 0x6c, 0x57, 0x25, 0x5a, 0x70, 0x5e, 0x1b, 0xff, 0x25, 0x3e, 0x0c, 
};
	PPTVTrackerReq *req = (PPTVTrackerReq *)pkt->data;
	if(req->cmd != 0x31) return;
	PPTVTrackerRsp rsp = {'\0'};
	//memcpy((uint8_t *)&rsp, a, sizeof(rsp));
	srand(time(NULL));
	rsp.cmd = 0x31;
	rsp.un20 = req->un20;
	rsp.un21 = req->un21;
	memcpy(rsp.vid, req->vid, sizeof(rsp.vid));
	rsp.cnt = 1;
	rsp.peerinfo.lanip = inet_network("192.168.1.43");
	rsp.peerinfo.lanport = 51515;
	rsp.peerinfo.delim = 0x010c;
	rsp.peerinfo.wanip = inet_network("192.168.1.43");
	rsp.peerinfo.wanport = 51515;
	rsp.peerinfo.un1 = 0x3db86421;
	rsp.peerinfo.un2 = 0xfeff1b5d;
	rsp.peerinfo.un3 = 0x35a3;
	rsp.un1 = pptvchecksum((uint8_t *)&rsp, sizeof(rsp));
	udp_send_rsp_pkt(pkt, (uint8_t *)&rsp, sizeof(rsp));
}

#define HTTP_VERSION	"HTTP/1.0 302 Found"
#define HTTP_SERVER		"Server: Apache"
#define HTTP_CONTENT	"Content-Length: 0"
#define HTTP_LOCATION	"Location: http://192.168.0.199/"
#define HTTP_CACHE		"Cache-Control: no-cache"
#define HTTP_CONNECTION "Connection: close"

void http_handle(struct packet *pkt)
{
	uint8_t buf[1500] = {'\0'};int offset = 0;uint8_t *bufPtr = &buf[0];
	sprintf(bufPtr + offset, "%s", HTTP_VERSION);
	offset += strlen(HTTP_VERSION);
	*(bufPtr + offset) = 0x0d; offset += 1; *(bufPtr + offset) = 0x0a; offset += 1;

	sprintf(bufPtr + offset, "%s", HTTP_SERVER);
	offset += strlen(HTTP_SERVER);
	*(bufPtr + offset) = 0x0d; offset += 1; *(bufPtr + offset) = 0x0a; offset += 1;

	sprintf(bufPtr + offset, "%s", HTTP_CONTENT);
	offset += strlen(HTTP_CONTENT);
	*(bufPtr + offset) = 0x0d; offset += 1; *(bufPtr + offset) = 0x0a; offset += 1;

	sprintf(bufPtr + offset, "%s", HTTP_LOCATION);
	offset += strlen(HTTP_LOCATION);
	*(bufPtr + offset) = 0x0d; offset += 1; *(bufPtr + offset) = 0x0a; offset += 1;

	sprintf(bufPtr + offset, "%s", HTTP_CACHE);
	offset += strlen(HTTP_CACHE);
	*(bufPtr + offset) = 0x0d; offset += 1; *(bufPtr + offset) = 0x0a; offset += 1;

	sprintf(bufPtr + offset, "%s", HTTP_CONNECTION);
	offset += strlen(HTTP_CONNECTION);
	*(bufPtr + offset) = 0x0d; offset += 1; *(bufPtr + offset) = 0x0a; offset += 1;

	*(bufPtr + offset) = 0x0d; offset += 1; *(bufPtr + offset) = 0x0a; offset += 1;

	tcp_send_rsp_pkt(pkt, buf, strlen(buf));
}

int ismatch_fingerprint(char *data, int len)
{
	int i;
	for(i = 0; i < sizeof(fingerprints)/sizeof(struct fingerprint); i++)
	{
		if(len < fingerprints[i].fingerprint_len) continue;
		if(memcmp(&data[fingerprints[i].fingerprint_offset], fingerprints[i].fingerprint, fingerprints[i].fingerprint_len) == 0)
			return fingerprints[i].fingerprint_owner;
	}
	return 0;
}

void data_handle(struct packet *pkt)
{
	char *data = pkt->data;
	int len = pkt->data_len;
	int ret = ismatch_fingerprint(data, len);
	switch(ret)
	{
		case SOHU_TRACKER_FINGERPRINT:
			sohu_tracker_handle(pkt);
			break;
		case SOHU_RESOURCE_FINGERPRINT:
			sohu_resource_handle(pkt);
			break;
		case PPS_RESOURCE_FINGERPRINT:
			pps_resource_handle(pkt);
			break;
		default:
			break;
	}
	uint16_t port = ntohs(pkt->tcp_hdr.tcp_destination_port);
	if(pkt->data_len == 84 && (port == 8000 || port == 8080))
	{
		int num = funshion_numOfDecode2(pkt->data);
		funshion_decode2_2(pkt->data, pkt->data_len);
		if(*(uint32_t*)&(pkt->data[8]) != 0x03000100)
			return;
		funshion_tracker_handle_tcp(pkt);
	}
#if 0 
	if(strstr(data, "www.baidu.com") != NULL)
	{
		http_handle(pkt);
	}
#endif
}

void packet_handle(struct packet *pkt)
{
	data_handle(pkt);
}

void udp_packet_handle(struct packet *pkt)
{
	char *data = pkt->data;
	int len = pkt->data_len;
	int ret = ismatch_fingerprint(data, len);
	switch(ret)
	{
		case PPS_TRACKER_FINGERPRINT:
			return pps_tracker_handle_udp(pkt);
		case IQY_TRACKER_FINGERPRINT:
			return iqiyi_tracker_handle_udp(pkt);
		case PPTV_TRACKER_FINGERPRINT:
			return pptv_tracker_handle_udp(pkt);
		default:
			break;
	}
//#if 0
	int num = funshion_numOfDecode2(pkt->data);
	funshion_decode2_2(pkt->data, pkt->data_len);
	if(*(uint32_t*)&(pkt->data[8]) != 0x03000100)
		return;
	funshion_tracker_handle_udp(pkt);
//#endif
}

void udp_protocol_packet_callback   
(   
 u_char                      *argument,   
 const struct pcap_pkthdr    *packet_header,   
 const u_char                *packet_content   
 )   
{
	struct udp_header   *udp_protocol;   
	udp_protocol = (struct udp_header *) (packet_content + sizeof(struct ether_header) + sizeof(struct ip_header));   

	struct packet *pkt = (struct packet *)argument;
	memcpy(&(pkt->udp_hdr), udp_protocol, sizeof(struct udp_header));

	int hdr_len = sizeof(struct ether_header) + sizeof(struct ip_header) + sizeof(struct udp_header);
	memcpy(pkt->data, packet_content + hdr_len, packet_header->len - hdr_len);
	pkt->data_len = packet_header->len - hdr_len;   

	char iptmpsrc[16] = {'\0'};
	char iptmpdst[16] = {'\0'};
	strcpy(iptmpsrc, inet_ntoa(pkt->ip_hdr.ip_source_address));   
	strcpy(iptmpdst, inet_ntoa(pkt->ip_hdr.ip_destination_address));   
	//printf("udp %s:%d->%s:%d len: %d\n", iptmpsrc, ntohs(pkt->udp_hdr.udp_source_port), iptmpdst,  ntohs(pkt->udp_hdr.udp_destination_port), pkt->data_len);

	//int dport = ntohs(pkt->udp_hdr.udp_destination_port);
	//if(pkt->data_len != 84 && dport != 8000 && dport != 8080)
	//	return;

	for(int i = 0; i < redirectipcnt; i++)
	{
		//if(pkt->ip_hdr.ip_destination_address.s_addr == redirectip[i])
		//	return;
	}

	udp_packet_handle(pkt);
}

void tcp_protocol_packet_callback   
(   
 u_char                      *argument,   
 const struct pcap_pkthdr    *packet_header,   
 const u_char                *packet_content   
 )   
{   
	struct tcp_header   *tcp_protocol;   
	tcp_protocol = (struct tcp_header *) (packet_content + sizeof(struct ether_header) + sizeof(struct ip_header));   

	struct packet *pkt = (struct packet *)argument;
	memcpy(&(pkt->tcp_hdr), tcp_protocol, sizeof(struct tcp_header));

	int hdr_len = sizeof(struct ether_header) + sizeof(struct ip_header) + sizeof(struct tcp_header);
	memcpy(pkt->data, packet_content + hdr_len, packet_header->len - hdr_len);
	pkt->data_len = packet_header->len - hdr_len;   

	char iptmpsrc[16] = {'\0'};
	char iptmpdst[16] = {'\0'};
	strcpy(iptmpsrc, inet_ntoa(pkt->ip_hdr.ip_source_address));   
	strcpy(iptmpdst, inet_ntoa(pkt->ip_hdr.ip_destination_address));   
	//printf("tcp %s:%d->%s:%d len: %d\n", iptmpsrc, ntohs(pkt->tcp_hdr.tcp_source_port), iptmpdst,  ntohs(pkt->tcp_hdr.tcp_destination_port), pkt->data_len);
	packet_handle(pkt);
}   

void ip_protocol_packet_callback   
(   
 u_char                      *argument,   
 const struct pcap_pkthdr    *packet_header,   
 const u_char                *packet_content   
 )   
{   
	struct ip_header    *ip_protocol;   
	ip_protocol = (struct ip_header *) (packet_content + sizeof(struct ether_header));   

	struct packet *pkt = (struct packet *)argument;
	memcpy(&(pkt->ip_hdr), ip_protocol, sizeof(struct ip_header));

	switch(ip_protocol->ip_protocol)   
	{   
		case 6:     
			tcp_protocol_packet_callback(argument, packet_header, packet_content); 
			break;   
		case 17:     
			udp_protocol_packet_callback(argument, packet_header, packet_content); 
			break;   
		default:    break;   
	}   
}   

void ethernet_protocol_packet_callback   
(   
 u_char                      *argument,   
 const struct pcap_pkthdr    *packet_header,   
 const u_char                *packet_content   
 )   
{   
	struct ether_header *ethernet_protocol;   
	ethernet_protocol = (struct ether_header *) packet_content;   

	struct packet pkt = {'\0'};
	memcpy(&(pkt.eth_hdr), ethernet_protocol, sizeof(struct ether_header));

	switch(ntohs(ethernet_protocol->ether_type))
	{   
		case 0x0800:    ip_protocol_packet_callback((u_char *)&pkt, packet_header, packet_content); break;   
		default:        break;   
	}   
}   

int main(int argc, char **argv)   
{
	char                error_content[PCAP_ERRBUF_SIZE];   
	char                net_interface[64] = {'\0'};   
	struct bpf_program  bpf_filter;   
	char                bpf_filter_string[256] = {'\0'};   
	bpf_u_int32         net_mask;   
	bpf_u_int32         net_ip;   
	if(argc < 2)
	{
		printf("usage: cmd if bpf\nexample: cmd eth1 port 80 and src 192.168.1.102\n");
		exit(-1);
	}

	strcpy(net_interface, argv[1]);

	pcap_handle_send = pcap_open_live("eth0", BUFSIZ, 1, 0, error_content);   
	pcap_handle = pcap_open_live(net_interface, BUFSIZ, 1, 0, error_content);   
	if(argc > 2)
	{
		int i = 0;
		for(i = 2; i < argc; i++)
		{	
			strcat(bpf_filter_string, argv[i]);
			strcat(bpf_filter_string, " ");
		}
		pcap_compile(pcap_handle, &bpf_filter, bpf_filter_string, 0, net_ip);   
		pcap_setfilter(pcap_handle, &bpf_filter);   
	}

	initKey2();
	initcrc32();
#if 0
	int ret = -1;
	ret = gethostinfo("ls.funshion.com", &redirectip[0]);
	if(ret < 0)
	{
		printf("get ls.funshion.com ip failed!\n");
		exit(-1);
	}

	redirectipcnt += ret;

	ret = gethostinfo("ls3.funshion.com", &redirectip[ret]);
	if(ret < 0)
	{
		printf("get ls3.funshion.com ip failed!\n");
		exit(-1);
	}

	redirectipcnt += ret;
#endif
	if(pcap_datalink(pcap_handle) != DLT_EN10MB) return -1;   
	pcap_loop(pcap_handle, -1, ethernet_protocol_packet_callback, NULL);   
	pcap_close(pcap_handle);   
}

```
